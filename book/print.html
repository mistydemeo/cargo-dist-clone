<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js oranda-dark">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>cargo-dist</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">
        <link rel="stylesheet" href="oranda-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "oranda-dark" : "oranda-dark";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('orandamdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('orandamdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('orandamdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('oranda-dark')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="install.html"><strong aria-hidden="true">2.</strong> Install</a></li><li class="chapter-item expanded "><a href="way-too-quickstart.html"><strong aria-hidden="true">3.</strong> Way Too Quick Start</a></li><li class="chapter-item expanded "><a href="updating.html"><strong aria-hidden="true">4.</strong> Updating</a></li><li class="chapter-item expanded "><a href="generic-builds.html"><strong aria-hidden="true">5.</strong> Generic Builds</a></li><li class="chapter-item expanded "><a href="installers/index.html"><strong aria-hidden="true">6.</strong> Installers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="installers/shell.html"><strong aria-hidden="true">6.1.</strong> shell</a></li><li class="chapter-item expanded "><a href="installers/powershell.html"><strong aria-hidden="true">6.2.</strong> powershell</a></li><li class="chapter-item expanded "><a href="installers/npm.html"><strong aria-hidden="true">6.3.</strong> npm</a></li><li class="chapter-item expanded "><a href="installers/homebrew.html"><strong aria-hidden="true">6.4.</strong> homebrew</a></li><li class="chapter-item expanded "><a href="installers/msi.html"><strong aria-hidden="true">6.5.</strong> msi</a></li></ol></li><li class="chapter-item expanded "><a href="artifacts/index.html"><strong aria-hidden="true">7.</strong> Artifacts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="artifacts/archives.html"><strong aria-hidden="true">7.1.</strong> archives</a></li><li class="chapter-item expanded "><a href="artifacts/checksums.html"><strong aria-hidden="true">7.2.</strong> checksums</a></li><li class="chapter-item expanded "><a href="artifacts/symbols.html"><strong aria-hidden="true">7.3.</strong> symbols</a></li></ol></li><li class="chapter-item expanded "><a href="ci/index.html"><strong aria-hidden="true">8.</strong> CI</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ci/github.html"><strong aria-hidden="true">8.1.</strong> github</a></li><li class="chapter-item expanded "><a href="ci/customizing.html"><strong aria-hidden="true">8.2.</strong> Customizing</a></li></ol></li><li class="chapter-item expanded "><a href="workspaces/index.html"><strong aria-hidden="true">9.</strong> Workspaces</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="workspaces/simple-guide.html"><strong aria-hidden="true">9.1.</strong> A Simple Application</a></li><li class="chapter-item expanded "><a href="workspaces/workspace-guide.html"><strong aria-hidden="true">9.2.</strong> More Complex Workspaces</a></li><li class="chapter-item expanded "><a href="workspaces/cargo-release-guide.html"><strong aria-hidden="true">9.3.</strong> Using cargo-release</a></li></ol></li><li class="chapter-item expanded "><a href="reference/index.html"><strong aria-hidden="true">10.</strong> Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/concepts.html"><strong aria-hidden="true">10.1.</strong> Concepts</a></li><li class="chapter-item expanded "><a href="reference/artifact-url.html"><strong aria-hidden="true">10.2.</strong> Artifact URLs</a></li><li class="chapter-item expanded "><a href="reference/config.html"><strong aria-hidden="true">10.3.</strong> Config</a></li><li class="chapter-item expanded "><a href="reference/cli.html"><strong aria-hidden="true">10.4.</strong> CLI Manual</a></li><li class="chapter-item expanded "><a href="reference/schema.html"><strong aria-hidden="true">10.5.</strong> dist-manifest.json</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="oranda-dark">Axo Dark</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="oranda-light">Axo Light</button></li>

                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">cargo-dist</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/axodotdev/cargo-dist" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><em>cargo-dist distributes your binaries</em></p>
<p>The TL;DR is that with cargo-dist setup, just doing this:</p>
<pre><code class="language-sh">git commit -am &quot;release: 0.2.0&quot;
git tag &quot;v0.2.0&quot;
git push
git push --tags
</code></pre>
<p>Will make <a href="https://github.com/axodotdev/axolotlsay/releases/tag/v0.2.0">this Github Release</a>:</p>
<p><img src="./img/simple-github-release.png" alt="A Github Release for &quot;axolotlsay 0.2.0&quot; with several installers and prebuilt binaries" /></p>
<p>Or if you're using <a href="https://opensource.axo.dev/oranda/">oranda</a>, you'll get <a href="https://opensource.axo.dev/axolotlsay/">this website</a>:</p>
<p><img src="./img/simple-oranda.png" alt="A website for &quot;axolotlsay&quot; that has a widget that detects the user's platform and suggests installation methods" /></p>
<h2 id="plan-build-host-publish-announce"><a class="header" href="#plan-build-host-publish-announce">Plan, Build, Host, Publish, Announce</a></h2>
<p>Cutting releases of your apps and distributing binaries for them has a lot of steps, and cargo-dist is quickly growing to try to cover them all!</p>
<p>To accomplish this, cargo-dist functionality can be broken up into two parts:</p>
<ul>
<li>building (<strong>planning</strong> the release; <strong>building</strong> binaries and installers)</li>
<li>distributing (<strong>hosting</strong> artifacts; <strong>publishing</strong> packages; <strong>announcing</strong> releases)</li>
</ul>
<p>The build functionality can be used on its own if you just want some tarballs and installers, but everything really comes together when you use the distribution functionality too.</p>
<h2 id="building"><a class="header" href="#building">Building</a></h2>
<p>As a build tool, cargo-dist can do the following:</p>
<ul>
<li>Pick good build flags for &quot;shippable binaries&quot;</li>
<li>Make <a href="./artifacts/archives.html">tarballs</a> and <a href="./installers/index.html">installers</a> for the resulting binaries</li>
<li>Generate <a href="./reference/schema.html">machine-readable manifests</a> so other tools can understand the results</li>
</ul>
<p>That's a short list because &quot;we make <a href="./installers/index.html">installers</a>&quot; is doing a lot of heavy lifting. Each installer could be (and sometimes is!) an entire standalone tool with its own documentation and ecosystem.</p>
<h2 id="distributing"><a class="header" href="#distributing">Distributing</a></h2>
<p>As a distribution tool, cargo-dist gets to flex its biggest superpower: <strong>it generates <a href="./ci/index.html">its own CI scripts</a></strong>. For instance, enabling <a href="./ci/github.html">GitHub CI</a> with <code>cargo dist init</code> will generate release.yml, which implements the full pipeline of plan, build, host, publish, announce:</p>
<ul>
<li>Plan
<ul>
<li>Waits for you to push a git tag for a new version (v1.0.0, my-app-1.0.0...)</li>
<li>Selects what apps in your workspace to announce new releases for based on that tag</li>
<li>Generates <a href="./reference/schema.html">a machine-readable manifest</a> with changelogs and build plans</li>
</ul>
</li>
<li>Build
<ul>
<li>Spins up machines for each platform you support</li>
<li>Builds your <a href="./artifacts/archives.html">binaries and tarballs</a></li>
<li>Builds <a href="./installers/index.html">installers</a> for your binaries</li>
</ul>
</li>
<li>Publish:
<ul>
<li>Uploads to package managers</li>
</ul>
</li>
<li>Host + Announce:
<ul>
<li>Creates (or edits and undrafts) a GitHub Release</li>
<li>Uploads build artifacts to the Release</li>
<li>Adds relevant release notes from your RELEASES/CHANGELOG</li>
</ul>
</li>
</ul>
<p>(Ideally &quot;host&quot; would come cleanly before &quot;publish&quot;, but GitHub Releases doesn't really properly support this kind of staging, so we're forced to race the steps a bit here. Future work may provide a more robust release process.)</p>
<p>Most of the scripts roughly amount to &quot;install cargo-dist&quot;, &quot;run it exactly once&quot;, &quot;upload the artifacts it reported&quot;. <strong>We want you to be able to copy that one cargo-dist invocation CI did, run it on your machine, and get the same results without any fuss</strong> (not to bit-level precision, but to the kinds of precision normal people expect from cargo builds). No setting up docker, no weird linux-only shell scripts that assume a bunch of tools were setup in earlier CI steps.</p>
<p>Of course even if we perfectly achieve this ideal, &quot;you <em>can</em> run it locally&quot; and &quot;you <em>want to</em> run it locally&quot; are different statements.</p>
<h2 id="check-your-release-process-early-and-often"><a class="header" href="#check-your-release-process-early-and-often">Check Your Release Process Early And Often</a></h2>
<p>To that point, <strong>release.yml can now run partially in pull-requests</strong>. The default is to only run the &quot;plan&quot; step, which includes many integrity checks to help prevent &quot;oops the release process is broken and we only found out when we tried to cut a release&quot;.</p>
<p><img src="./img/pr-fail.png" alt="A GitHub PR for &quot;chore: innocently update the Cargo.toml (to cause problems)&quot;, with the Release / plan PR check failing as a result" /></p>
<p>You can also crank the pull-request mode up to include the &quot;build&quot; step, in which case the PR Workflow Summary will include an artifacts.zip containing all the build results. We don't recommend keeping this on all the time (it's slow and wasteful), but it can be useful to temporarily turn on while testing a PR.</p>
<p><img src="./img/workflow-artifacts.png" alt="A GitHub Workflow Summary from running cargo-dist's release.yml with an &quot;artifacts&quot; download link at the bottom" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="install"><a class="header" href="#install">Install</a></h1>
<ul>
<li><a href="install.html#use-the-installer-scripts">Use The Installer Scripts</a></li>
<li><a href="install.html#build-from-source-with-cargo">Build From Source With Cargo</a></li>
<li><a href="install.html#install-prebuilt-binaries-with-cargo-binstall">Install Prebuilt Binaries With cargo-binstall</a></li>
<li><a href="install.html#installation-on-arch-linux">Installation on Arch Linux</a></li>
<li><a href="install.html#download-prebuilt-binaries-from-github-releases">Download Prebuilt Binaries From Github Releases</a></li>
</ul>
<p>Surprise! The tool for prebuilt shippable binaries has way too many ways to install it!
Whichever way you choose to install it, it should be invocable as <code>cargo dist ...</code>. If you insist on invoking the binary directly as <code>cargo-dist</code> you must still add the extra <code>dist</code> arg and invoke it as <code>cargo-dist dist ...</code> (a quirk of the way cargo invokes subcommands).</p>
<h2 id="use-the-installer-scripts"><a class="header" href="#use-the-installer-scripts">Use The Installer Scripts</a></h2>
<p>macOS and Linux (not NixOS, Alpine, or Asahi):</p>
<pre><code class="language-sh">curl --proto '=https' --tlsv1.2 -LsSf https://github.com/axodotdev/cargo-dist/releases/latest/download/cargo-dist-installer.sh | sh
</code></pre>
<p>Windows PowerShell:</p>
<pre><code class="language-sh">irm https://github.com/axodotdev/cargo-dist/releases/latest/download/cargo-dist-installer.ps1 | iex
</code></pre>
<h2 id="build-from-source-with-cargo"><a class="header" href="#build-from-source-with-cargo">Build From Source With Cargo</a></h2>
<pre><code class="language-sh">cargo install cargo-dist --locked
</code></pre>
<h2 id="install-prebuilt-binaries-with-cargo-binstall"><a class="header" href="#install-prebuilt-binaries-with-cargo-binstall">Install Prebuilt Binaries With cargo-binstall</a></h2>
<pre><code class="language-sh">cargo binstall cargo-dist
</code></pre>
<h2 id="installation-on-arch-linux"><a class="header" href="#installation-on-arch-linux">Installation on Arch Linux</a></h2>
<p>Arch Linux users can install <code>cargo-dist</code> from the <a href="https://archlinux.org/packages/extra/x86_64/cargo-dist/">extra repository</a> using <a href="https://wiki.archlinux.org/title/Pacman">pacman</a>:</p>
<pre><code class="language-sh">pacman -S cargo-dist
</code></pre>
<h2 id="download-prebuilt-binaries-from-github-releases"><a class="header" href="#download-prebuilt-binaries-from-github-releases">Download Prebuilt Binaries From Github Releases</a></h2>
<p><a href="https://github.com/axodotdev/cargo-dist/releases/latest">See The Latest Release</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="way-too-quickstart"><a class="header" href="#way-too-quickstart">Way-Too-Quickstart</a></h1>
<ul>
<li><a href="way-too-quickstart.html#setup">Setup</a>
<ul>
<li><a href="way-too-quickstart.html#initial-setup">Initial Setup</a></li>
<li><a href="way-too-quickstart.html#adding-installers">Adding Installers</a></li>
</ul>
</li>
<li><a href="way-too-quickstart.html#test-it-out">Test It Out</a>
<ul>
<li><a href="way-too-quickstart.html#build-for-the-current-platform">Build For The Current Platform</a></li>
<li><a href="way-too-quickstart.html#check-what-ci-will-build">Check What CI Will Build</a></li>
<li><a href="way-too-quickstart.html#check-the-release-process-on-pull-requests">Check The Release Process On Pull-Requests</a></li>
</ul>
</li>
<li><a href="way-too-quickstart.html#cut-a-release-trigger-github-ci">Cut A Release (Trigger Github CI)</a></li>
</ul>
<blockquote>
<p>TLDR: cargo-dist is a souped up version of <code>cargo build</code> which handles building <a href="./artifacts/archives.html">tarballs</a> and <a href="./installers/index.html">installers</a>. It also knows how to generate Github CI for orchestrating itself and uploading its output to a new GitHub Release. You can use cargo-dist if you don't care about that CI stuff, but this guide assumes that you do.</p>
<p>This quickstart is a bit <em>too</em> quick because there's some important nuances to &quot;announcing and building releases&quot; that depend on the way you like to structure and version your workspace. We will blatantly ignore those nuances and show you the Happiest Happy Path (a workspace with one crate that defines a binary). Checkout <a href="./workspaces/index.html">the workspace guide</a> for more details on what you should <em>actually</em> do.</p>
</blockquote>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<p>Setting up just requires you to <a href="./install.html">install cargo-dist</a> and then run <code>cargo dist init</code> in your <a href="https://doc.rust-lang.org/cargo/reference/workspaces.html">Cargo workspace</a>. This command interactively walks you through configuration options, <strong>and should be run again whenever you want to change your settings or want to update cargo-dist</strong>.</p>
<p>Just to really emphasize that: <code>cargo dist init</code> is designed to be rerun over and over, and will preserve your settings while handling any necessary updates and migrations. Always Be Initing.</p>
<h3 id="initial-setup"><a class="header" href="#initial-setup">Initial Setup</a></h3>
<p>Since this is the <em>way-too</em>-quickstart, we pass <code>--yes</code> to auto-accept all defaults on our first setup!</p>
<pre><code class="language-sh"># install tools (build from source is the most portable option)
cargo install cargo-dist

# setup cargo-dist in your project (--yes to accept defaults)
cargo dist init --yes
git add .
git commit -am &quot;chore: wow shiny new cargo-dist CI!&quot;
</code></pre>
<p>The one-time setup will add a decent default configuration to your root Cargo.toml and generate CI for orchestrating itself in <code>.github/workflows/release.yml</code>. If the CI file isn't created, this probably means you don't have <code>repository = &quot;https://github.com/...&quot;</code> consistently set in your Cargo.toml(s).</p>
<h3 id="adding-installers"><a class="header" href="#adding-installers">Adding Installers</a></h3>
<p>The most common reason to update cargo-dist or mess with its config is to add a new <a href="./installers/index.html">installer</a>, which is basically our blanket term for anything more fancy than <a href="./artifacts/archives.html">tarballs</a> (curl-sh scripts, npm packages, msi installers, ...).</p>
<p>You can skip this step for now and just test out the basics the initial setup gives you. Each individual <a href="./installers/index.html">installer</a> should have a guide that assumes you did the initial setup.</p>
<p>The tl;dr of those guides is &quot;run <code>cargo dist init</code> again, select the installer you want to add, and fill in any extra details that are needed&quot;.</p>
<h2 id="test-it-out"><a class="header" href="#test-it-out">Test It Out</a></h2>
<p>There are a several ways to test out cargo-dist before committing to running a proper release:</p>
<ol>
<li>build for the current platform (<code>cargo dist build</code>)</li>
<li>check what CI will build (<code>cargo dist plan</code>)</li>
<li>check the release process on pull-requests</li>
</ol>
<h3 id="build-for-the-current-platform"><a class="header" href="#build-for-the-current-platform">Build For The Current Platform</a></h3>
<pre><code class="language-sh">cargo dist build
</code></pre>
<p><img src="./img/quickstart-build.png" alt="Running &quot;cargo dist build&quot; on a project, resulting in the application getting built and bundled into a .zip, and an &quot;installer.ps1&quot; script getting generated. Paths to these files are printed along with some metadata." /></p>
<p>The <a href="./reference/cli.html#cargo-dist-build">build command</a> will by default try to build things for the computer you're running it on. So if you run it on linux you might get a <code>tar.xz</code> containing your binary and an installer.sh, but if you run it on windows you might get a <code>zip</code> and an installer.ps1.</p>
<p>cargo-dist will then spit out paths to the files it created, so you can inspect their contents and try running them (<strong>note that installer scripts probably won't be locally runnable, because they will try to fetch their binaries from GitHub</strong>).</p>
<h3 id="check-what-ci-will-build"><a class="header" href="#check-what-ci-will-build">Check What CI Will Build</a></h3>
<pre><code class="language-sh">cargo dist plan
</code></pre>
<p><img src="./img/quickstart-plan.png" alt="Running &quot;cargo dist plan&quot; on a project, producing a full printout of the tarballs/zips that will be produced for all platforms (mac, linux, windows), and all installers (shell, powershell)" /></p>
<p>The <a href="./reference/cli.html#cargo-dist-plan">plan command</a> should be running the exact same logic that cargo-dist's generated CI will run, but without actually building anything. This lets you quickly check what cutting a new release will produce. It will also try to catch any inconsistencies that could make the CI error out.</p>
<h3 id="check-the-release-process-on-pull-requests"><a class="header" href="#check-the-release-process-on-pull-requests">Check The Release Process On Pull-Requests</a></h3>
<p>As of cargo-dist 0.3.0, we now by default run the &quot;plan&quot; step of your release CI on every pull-request so that we can catch breakage to your release process as early as possible. This will work even for a pull-request that sets up cargo-dist for the first time, so you can be confident you're landing something that works.</p>
<p>You can also crank this up by setting <code>pr-run-mode = &quot;upload&quot;</code>, which will run all the build steps as well, and upload the results to the PR's Workflow Summary as an &quot;artifacts.zip&quot;. This is great for making sure the windows build works even if you only have a linux machine, or vice-versa. Although you should probably only keep it on temporarily, as it's very slow and wasteful to build all those shippable artifacts for every PR.</p>
<h2 id="cut-a-release-trigger-github-ci"><a class="header" href="#cut-a-release-trigger-github-ci">Cut A Release (Trigger Github CI)</a></h2>
<p>cargo-dist largely doesn't care about the details of how you prepare your release, and doesn't yet provide tools to streamline it. All it cares about is you getting your release branch into the state you want, and then pushing a properly formatted git tag like &quot;v0.1.0&quot;. Here's a super bare-bones release process where we're releasing by just pushing a bunch of stuff to main branch (but it would work just as well with PRs and release branches):</p>
<pre><code class="language-sh"># &lt;manually update the version of your crate, run tests, etc&gt;

# commit and push to main (can be done with a PR)
git commit -am &quot;release: version 0.1.0&quot;
git push

# actually push the tag up (this triggers cargo-dist's CI)
git tag v0.1.0
git push --tags

# publish to crates.io (optional)
cargo publish
</code></pre>
<p>The important parts are that you update the crates you want to release/announce to the desired version and push a git tag with that version.</p>
<p>At this point you're done! The generated CI script should pick up the ball and create a Github Release with all your builds over the next few minutes!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="updating"><a class="header" href="#updating">Updating</a></h1>
<p>Just</p>
<p><code>cargo dist init</code></p>
<p>That's it!</p>
<p>Rerun init as much as you want, it should always preserve your old settings, and should never break anything (if it does, it's a bug!).</p>
<p>If you have a project with cargo-dist setup on it, and want to upgrade to a new version, all you should ever need to do is locally install the new version of cargo-dist and run <code>cargo dist init</code>.</p>
<p>If you're simply adjusting your cargo-dist config, you should also rerun <code>cargo dist init</code> to potentially get informed of new features/constraints your change runs into. It also ensures that things like your ci.yml are updated to reflect your new config. Basically every other cargo-dist command should error out if you <em>have</em> to rerun init, so you won't get far if you don't.</p>
<p>We recommend running without <code>-y</code> for reruns, because this is the chance cargo-dist has to tell you about new features, or additional configuration that pairs with any adjustments you may have made. It will take that chance to ask you if you want to enable the feature or change the default value.</p>
<p>In general the init command is designed to do incremental updates to your installation, and &quot;first setup&quot; is just a special case of this, where every incremental update is applicable.</p>
<p>The command usually uses the absence of a setting in your config to determine if a feature has been setup before. As such, even though cargo-dist <em>generally</em> has default values for every piece of config, init will aggressively write the default back to your config to let future invocations know they don't need to ask about it.</p>
<p>Which also means if you missed a prompt or want to reconfigure a feature, deleting the relevant setting from your config and rerunning <code>init</code> should work.</p>
<p>There are two settings that init will always prompt you for:</p>
<ul>
<li>what platforms do you want to build for</li>
<li>what installers do you want to have</li>
</ul>
<p>So if you ever want to add a new platform or installer, rerunning <code>cargo dist init</code> is a great way to do that -- and then it can ask followup questions if you turn on a new installer!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-builds"><a class="header" href="#generic-builds">Generic Builds</a></h1>
<blockquote>
<p>since 0.5.0</p>
</blockquote>
<p>Although cargo-dist was originally designed specifically for Cargo-based builds, we've introduced experimental features to allow you to use it to build and distribute any software written in any language. This feature is currently a <em>prerelease</em>: details may change before it becomes stable.</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<ul>
<li><a href="https://github.com/axodotdev/axolotlsay-js">example npm project</a></li>
<li><a href="https://github.com/axodotdev/cargo-dist-c-example">example C project</a></li>
</ul>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>In order for cargo-dist to recognize your application, it requires a <a href="https://en.wikipedia.org/wiki/TOML">TOML</a> configuration file named <code>dist.toml</code>. This file is similar to Cargo's <a href="https://doc.rust-lang.org/cargo/reference/manifest.html"><code>Cargo.toml</code></a>, so users who are already familiar with Cargo should feel comfortable right away. Many of <code>dist.toml</code>'s fields are identical to <code>Cargo.toml</code>, but there are a few extra fields specific to this file.</p>
<p><code>dist.toml</code> has two mandatory sections: <code>package</code>, which you write yourself and which contains information about your application; and <code>dist</code>, which contains cargo-dist's configuration and which <code>cargo-dist init</code> generates for you.</p>
<p>To get started, write a <code>dist.toml</code> containing just a <code>package</code> section. A simple one looks like this:</p>
<pre><code class="language-toml">[package]
# Your app's name
name = &quot;my_app&quot;
# The current version; make sure to keep this up to date!
version = &quot;0.1.0&quot;
# The URL to the git repository; this is used
repository = &quot;https://example.com&quot;
# The executables your app produces
binaries = [&quot;main&quot;]
# The build command cargo-dist runs to produce those binaries
build-command = [&quot;make&quot;]
</code></pre>
<h2 id="quickstart"><a class="header" href="#quickstart">Quickstart</a></h2>
<p>Once you've produced a configuration file, you can run <code>cargo dist init</code> and let cargo-dist generate its own configuration. From here, the build and usage process looks very much like the normal cargo-dist setup; for more information, check the <a href="/book/way-too-quickstart.html">main quickstart documentation</a>.</p>
<h3 id="understanding-build-commands"><a class="header" href="#understanding-build-commands">Understanding build commands</a></h3>
<p>Build commands are the core difference between these builds and regular cargo-dist. Since we don't have Cargo to rely on to tell us how to build your package, it's up to you to tell us how instead.</p>
<p>As an example, the above application is a C program with a simple makefile-based buildsystem. All you need to run to build this program is <code>make</code>, so we specified <code>build-command = [&quot;make&quot;]</code>. If your app has a more complex build that will require multiple commands to run, it may be easier for you to add a build script to your repository. In that case, <code>build-command</code> can simply be a reference to executing it:</p>
<pre><code class="language-toml">build-command = [&quot;./build.sh&quot;]
</code></pre>
<p>We expose a special environment variable called <code>CARGO_DIST_TARGET</code> into your build. It contains a <a href="https://doc.rust-lang.org/nightly/rustc/platform-support.html">Rust-style target triple</a> for the platform we expect your build to build for. Depending on the language of the software you're building, you may need to use this to set appropriate cross-compilation flags. For example, when cargo-dist is building for an Apple Silicon Mac, we'll set <code>aarch64-apple-darwin</code> in order to allow your build to know when it should build for aarch64 even if the host is x86_64.</p>
<p>On macOS, we expose several additional environment variables to help your buildsystem find dependencies. In the future, we may add more environment variables on all platforms.</p>
<ul>
<li><code>CFLAGS</code>/<code>CPPFLAGS</code>: Flags used by the C preprocessor and C compiler while building.</li>
<li><code>LDFLAGS</code>: Flags used by the C linker.</li>
<li><code>PKG_CONFIG_PATH</code>/<code>PKG_CONFIG_LIBDIR</code>: Paths for <code>pkg-config</code> to help it locate packages.</li>
<li><code>CMAKE_INCLUDE_PATH</code>/<code>CMAKE_LIBRARY_PATH</code>: Paths for <code>cmake</code> to help it locate packages' configuration files.</li>
</ul>
<h3 id="mandatory-package-fields"><a class="header" href="#mandatory-package-fields">Mandatory package fields</a></h3>
<p>These package fields are mandatory for cargo-dist to be able to build your package:</p>
<ul>
<li><code>name</code>: Your application's name.</li>
<li><code>version</code>: The application's version. Currently, this must be in a <a href="https://semver.org">Semver</a>-compatible format.</li>
<li><code>repository</code>: The URL to a git repository containing your application's source code.</li>
<li><code>binaries</code>: An array of one or more executables your application's build will produce. The strings within this array are paths relative to your application's build directory; for example, if you produce a binary named <code>main</code> within the <code>./src</code> directory, you can specify <code>[&quot;src/main&quot;]</code>.</li>
<li><code>build-command</code>: The command cargo-dist should run in order to build your application. This is an array of one or more strings; the first string is the command cargo-dist will run, and any subsequent strings are arguments to pass to that command.</li>
</ul>
<h3 id="optional-package-fields"><a class="header" href="#optional-package-fields">Optional package fields</a></h3>
<p>All of these fields and their definitions are identical to the ones defined by [<code>Cargo.lock</code>][cargo-lock].</p>
<ul>
<li><code>cstaticlibs</code>: An array of one or more C static libraries (<code>.a</code> files) produced by your application's build.</li>
<li><code>cdynamiclibs</code>: An array of one or more C dynamic libraries produced by your application's build.</li>
<li><code>changelog</code>: The path to the application's changelog within its source code. This will be used for the text of release announcements.</li>
<li><code>documentation</code>: The URL to where the application's documentation can be accessed.</li>
<li><code>description</code>: A human-readable description of the application.</li>
<li><code>readme</code>: The path to the application's README within its source code.</li>
<li><code>authors</code>: An array containing the names of the application's developers.</li>
<li><code>license</code>: The application's license, as an <a href="https://spdx.org/licenses">SPDX identifier</a>.</li>
<li><code>license-files</code>: An array containing a list of one or more license files within the source code.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installers"><a class="header" href="#installers">Installers</a></h1>
<p>The core functionality of cargo-dist is to build your binaries and produce <a href="installers/../artifacts/archives.html">tarballs / zips</a> containing them. Basically every other kind of output it produces is considered an &quot;installer&quot; that helps download/install/run those binaries.</p>
<p>Note that we use the term &quot;installer&quot; very loosely -- if it's fancier than a tarball, it's an installer to us!</p>
<h2 id="supported-installers"><a class="header" href="#supported-installers">Supported Installers</a></h2>
<p>Currently supported installers include:</p>
<ul>
<li><a href="installers/./shell.html">shell</a>: a shell script that fetches and installs executables (for <code>curl | sh</code>)</li>
<li><a href="installers/./powershell.html">powershell</a>: a powershell script that fetches and installs executables (for <code>irm | iex</code>)</li>
<li><a href="installers/./npm.html">npm</a>: an npm project that fetches and runs executables (for <code>npx</code>)</li>
<li><a href="installers/./homebrew.html">homebrew</a>: a Homebrew formula that fetches and installs executables</li>
<li><a href="installers/./msi.html">msi</a>: a Windows msi that bundles and installs executables</li>
</ul>
<p>These keys can be specified via <a href="installers/../reference/config.html#installers"><code>installer</code> in your cargo-dist config</a>. The <a href="installers/../reference/cli.html#cargo-dist-init"><code>cargo dist init</code> command</a> provides an interactive UI for enabling/disabling them.</p>
<p>The above installers can have one of two strategies: <em>fetching</em> and <em>bundling</em> (defined below). Currently each installer is hardcoded to one particular strategy, but in the future <a href="https://github.com/axodotdev/cargo-dist/issues/450">we may make it configurable</a>.</p>
<h2 id="future-installers"><a class="header" href="#future-installers">Future Installers</a></h2>
<p>The following installers have been requested, and we're open to supporting them, but we have no specific timeline for when they will be implemented. Providing additional info/feedback on them helps us prioritize the work:</p>
<ul>
<li><a href="https://github.com/axodotdev/cargo-dist/issues/365">linux docker image containing binaries</a></li>
<li><a href="https://github.com/axodotdev/cargo-dist/issues/25">linux flatpak</a></li>
<li><a href="https://github.com/axodotdev/cargo-dist/issues/309">macOS cask</a></li>
<li><a href="https://github.com/axodotdev/cargo-dist/issues/24">macOS dmg / app</a></li>
<li><a href="https://github.com/axodotdev/cargo-dist/issues/86">pypi package</a></li>
<li><a href="https://github.com/axodotdev/cargo-dist/issues/87">windows winget package</a></li>
</ul>
<h2 id="fetching-installers"><a class="header" href="#fetching-installers">Fetching Installers</a></h2>
<p>Fetching installers are thin wrappers which detect the user's current platform and download and unpack the appropriate <a href="installers/../artifacts/archives.html">archive</a> from a server.</p>
<p>In exchange for requiring <a href="installers/../reference/artifact-url.html">a well-defined Artifact URL</a> and an internet connection at install-time, this strategy gives you a simple and efficient way to host prebuilt binaries and make sure that all users get the same binaries regardless of how the installed your application.</p>
<p>Fetching installers are also easy to make &quot;universal&quot; (cross-platform), so your installing users don't need to care about the OS or CPU they're using -- the installer will handle that for them.</p>
<p>Installers which support fetching:</p>
<ul>
<li><a href="installers/./shell.html">shell</a>: a shell script that fetches and installs executables (for <code>curl | sh</code>)</li>
<li><a href="installers/./powershell.html">powershell</a>: a powershell script that fetches and installs executables (for <code>irm | iex</code>)</li>
<li><a href="installers/./npm.html">npm</a>: an npm project that fetches and runs executables (for <code>npx</code>)</li>
<li><a href="installers/./homebrew.html">homebrew</a>: a Homebrew formula that fetches and installs executables</li>
</ul>
<h2 id="bundling-installers"><a class="header" href="#bundling-installers">Bundling Installers</a></h2>
<p>Bundling installers contain the actual binaries they will install on the user's system.</p>
<p>These installers can work without any internet connection, which some users will demand or appreciate.</p>
<p>Bundling requires a fundamental compromise when it comes to &quot;universal&quot; (cross-platform) installers, as any installer that wants to support e.g. <a href="https://github.com/axodotdev/cargo-dist/issues/77">Intel macOS and Apple Silicon macOS</a> will need to include both binaries, even if only one will ever be used.</p>
<p>For this reason all bundling installers are currently single-platform, requiring the installing user to know what platform they're on.</p>
<p>Installers which support bundling:</p>
<ul>
<li><a href="installers/./msi.html">msi</a>: a Windows msi that bundles and installs executables</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shell-script-installer"><a class="header" href="#shell-script-installer">Shell Script Installer</a></h1>
<blockquote>
<p>since 0.0.3</p>
</blockquote>
<p>The &quot;shell&quot; installer provides a shell script (my-app-installer.sh) which detects the current platform, fetches the best possible <a href="installers/../artifacts/archives.html">archive</a> from your <a href="installers/../reference/artifact-url.html">Artifact URL</a>, copies the binary into your <a href="installers/../reference/config.html#install-path">install-path</a>, and attempts to add that path to the user's PATH (see the next section for details).</p>
<p>This kind of installer is ideal for bootstrapping setup on a fairly bare-bones system.</p>
<p>An &quot;installer hint&quot; will be provided that shows how to install via <code>curl | sh</code>, like so:</p>
<pre><code class="language-sh">curl --proto '=https' --tlsv1.2 -LsSf https://github.com/axodotdev/cargo-dist/releases/download/v0.0.5/cargo-dist-v0.0.5-installer.sh | sh
</code></pre>
<p>Limitations/Caveats:</p>
<ul>
<li>Requires a well-defined <a href="installers/../reference/artifact-url.html">Artifact URL</a></li>
<li>Currently only really designed for &quot;linux&quot; and &quot;macOS&quot;, and won't detect other platforms properly (and certainly won't play nice with things like nixOS).</li>
<li><a href="https://github.com/axodotdev/cargo-dist/issues/75">Cannot detect situations where musl-based builds are appropriate</a> (static or dynamic)</li>
<li>Relies on the user's installation of <code>tar</code> and <code>unzip</code> to unpack the files</li>
<li>Relies on the the user's installation of <code>curl</code> or <code>wget</code> to fetch the files</li>
<li><a href="https://github.com/axodotdev/cargo-dist/issues/307">Will throw out all files except for the binary, so the binary can't rely on assets included in the archive</a></li>
<li>Cannot run any kind of custom install logic</li>
</ul>
<p>In an ideal world all of these caveats improve (except for maybe relying on tar/unzip/curl/wget, that's kinda fundamental).</p>
<h2 id="adding-things-to-path"><a class="header" href="#adding-things-to-path">Adding things to PATH</a></h2>
<p>Here is a more fleshed out description of how the shell installer attempts to add the <a href="installers/../reference/config.html#install-path">install-path</a> to the user's PATH, and the limitations of that process.</p>
<p>The most fundamental limitation is that installers fundamentally cannot edit the PATH of the currently running shell (it's a parent process). Only an explicit <code>source some_file</code> (or the more portable <code>. some_file</code>) can do that. As such, it benefits an installer to try to install to a directory that will already be on PATH (such as <a href="https://doc.rust-lang.org/cargo/guide/cargo-home.html">CARGO_HOME</a>). Otherwise all we can do is prompt the user to run <code>source</code> themselves after the installer has run (or restart their shell to freshly source rcfiles).</p>
<p>The process we use to add <a href="installers/../reference/config.html#install-path">install-path</a> to the user's PATH is roughly the same process that rustup uses (hopefully making us harmonious with running rustup before/after one of our installer scripts). In the following description we will use <code>$install-path</code> as a placeholder for the path computed at install-time where the binaries get installed. Its actual value will likely look something like <code>$HOME/.myapp</code> or <code>$HOME/.cargo/bin</code>.</p>
<ul>
<li>we generate a shell script and write it to <code>$install-path/env</code> (let's call this <code>$env-path</code>)
<ul>
<li>the script checks if <code>$install-path</code> is in PATH already, and prepends it if not</li>
<li>prepending is used to ideally override system-installed binaries, as that is assumed to be desired when explicitly installing with not-your-system-package-manager</li>
<li>the <code>env</code> script will only be added if it doesn't already exist</li>
<li>if <code>install-path = &quot;CARGO_HOME&quot;</code>, then <code>$env-path</code> will actually be in the parent directory, mirroring the behaviour of rustup</li>
</ul>
</li>
<li>we add <code>. $env-path</code> to <code>$HOME/.profile</code>
<ul>
<li>this is just a more portable version of <code>source $install-path/env</code></li>
<li>this line will only be added if it doesn't exist (we also check for the <code>source</code> equivalent)</li>
<li>the file is created if it doesn't exist</li>
<li><a href="https://github.com/rust-lang/rustup/blob/bcfac6278c7c2f16a41294f7533aeee2f7f88d07/src/cli/self_update/shell.rs#L70-L76">rustup shotgun blasts this line into many more files like .bashrc and .zshenv</a>, while still <a href="https://github.com/rust-lang/rustup/issues/478">lacking proper support for fish</a> and other more obscure shells -- we opted to start conservative with just .profile</li>
</ul>
</li>
<li>if <code>$HOME/.profile</code> was edited, we prompt the user to <code>source &quot;$env-path&quot;</code> or restart their shell
<ul>
<li>although this is less portable than <code>. &quot;$env-path&quot;</code>, it's very easy to misread/miscopy the portable version (not as much of a concern for an rcfile, but an issue for humans)</li>
<li>hopefully folks on platforms where this matters are aware of this issue (or they can restart their shell)</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="powershell-script-installer"><a class="header" href="#powershell-script-installer">PowerShell Script Installer</a></h1>
<blockquote>
<p>since 0.0.3</p>
</blockquote>
<p>This provides a powershell script (my-app-installer.ps1) which detects the current platform, fetches the best possible <a href="installers/../artifacts/archives.html">archive</a> from your <a href="installers/../reference/artifact-url.html">Artifact URL</a>, copies the binary into your <a href="installers/../reference/config.html#install-path">install-path</a>, and attempts to add that path to the user's PATH (see the next section for details).</p>
<p>This kind of installer is ideal for bootstrapping setup on a fairly bare-bones system.</p>
<p>An &quot;installer hint&quot; will be provided that shows how to install via <code>irm | iex</code> (the windows equivalent of <code>curl | sh</code>), like so:</p>
<pre><code class="language-sh">irm https://github.com/axodotdev/cargo-dist/releases/download/v0.0.5/cargo-dist-v0.0.5-installer.ps1 | iex
</code></pre>
<p>Limitations/Caveats:</p>
<ul>
<li>Requires a well-defined <a href="installers/../reference/artifact-url.html">Artifact URL</a></li>
<li>Currently only really designed for &quot;native windows&quot;, and won't detect other platforms properly</li>
<li><a href="https://github.com/axodotdev/cargo-dist/issues/75">Cannot detect situations where musl-based builds are appropriate</a> (static or dynamic)</li>
<li>Relies on the user's installation of <code>tar</code> and <code>Expand-Archive</code> to unpack the files</li>
<li>Relies on the the user's installation of <code>Net.Webclient</code> to fetch the files</li>
<li><a href="https://github.com/axodotdev/oranda/issues/393">Won't work if run in cmd instead of powershell</a></li>
<li><a href="https://github.com/axodotdev/cargo-dist/issues/307">Will throw out all files except for the binary, so the binary can't rely on assets included in the archive</a></li>
<li>Cannot run any kind of custom install logic</li>
</ul>
<p>On the scale of Windows (where many people are still running Windows 7) commands like &quot;Expand-Archive&quot; and &quot;tar&quot; are in fact relatively new innovations. Any system that predates 2016 (PowerShell 5.0) certainly has no hope of working. I believe that someone running Windows 10 is basically guaranteed to work, and anything before that gets sketchier.</p>
<p>In an ideal world most of these caveats improve (except for maybe the requirement of PowerShell &gt;= 5.0 which is not pleasant to push past).</p>
<h2 id="adding-things-to-path-1"><a class="header" href="#adding-things-to-path-1">Adding things to PATH</a></h2>
<p>Here is a more fleshed out description of how the powershell installer attempts to add the <a href="installers/../reference/config.html#install-path">install-path</a> to the user's PATH, and the limitations of that process.</p>
<p>The most fundamental limitation is that installers fundamentally cannot edit the PATH of the currently running shell (it's a parent process). Powershell does not have an equivalent of <code>source</code>, so to the best of our knowledge restarting the shell is the only option (which if using Windows Terminal seems to mean opening a whole new window, tabs aren't good enough). As such, it benefits an installer to try to install to a directory that will already be on PATH (such as <a href="https://doc.rust-lang.org/cargo/guide/cargo-home.html">CARGO_HOME</a>). (<a href="https://github.com/rust-lang/rustup/blob/bcfac6278c7c2f16a41294f7533aeee2f7f88d07/src/cli/self_update/windows.rs#L397-L409">rustup also sends a broadcast WM_SETTINGCHANGE message</a>, but we couldn't find any evidence that this does anything useful.)</p>
<p>The process we use to add <a href="installers/../reference/config.html#install-path">install-path</a> to the user's PATH is roughly the same process that rustup uses (hopefully making us harmonious with running rustup before/after one of our installer scripts). In the following description we will use <code>$install-path</code> as a placeholder for the path computed at install-time where the binaries get installed. Its actual value will likely look something like <code>C:\Users\axo\.myapp</code> or <code>C:\Users\.cargo\bin</code>.</p>
<ul>
<li>we load from the registry <code>HKCU:\Environment</code>'s &quot;Path&quot; Item</li>
<li>we check if <code>$install-path</code> is contained within it already</li>
<li>if not, we prepend it and write the value back
<ul>
<li>prepending is used to ideally override system-installed binaries, as that is assumed to be desired when explicitly installing with not-your-system-package-manager</li>
</ul>
</li>
<li>if we edited the registry, we prompt the user to restart their shell</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="npm-installer"><a class="header" href="#npm-installer">npm Installer</a></h1>
<blockquote>
<p>since 0.0.6</p>
</blockquote>
<p>This provides a tarball containing an npm package (npm-package.tar.gz) which when installed into an npm project: detects the current platform, fetches the best possible <a href="installers/../artifacts/archives.html">archive</a> from your <a href="installers/../reference/artifact-url.html">artifact URL</a>, and copies the binary into your node_modules. This can be used to install the binaries like any other npm package, or to run them with <code>npx</code>.</p>
<p>This kind of installer is ideal for making a native Rust tool available to JS devs.</p>
<p>An &quot;installer hint&quot; will be provided that shows how to install via <code>npm</code> like so:</p>
<pre><code class="language-sh">npm install @axodotdev/cargodisttest@0.2.0
</code></pre>
<p><strong>cargo-dist does not publish the package for you, you need to do that manually once the tarball is built.</strong> Conveniently, npm supports publishing from a url-to-a-tarball directly, and since 0.0.7 we make our tarballs look like &quot;proper&quot; npm package tarballs, so you can just do this:</p>
<pre><code class="language-sh">npm publish URL_TO_TARBALL
</code></pre>
<p>You can find the URL to the tarball at the bottom of the Github Release, inside the collapsible &quot;assets&quot; dropdown (*-npm-package.tar.gz). The format of the url is:</p>
<pre><code class="language-text">&lt;repo&gt;/releases/download/&lt;tag&gt;/&lt;app-name&gt;-npm-package.tar.gz
</code></pre>
<p>Example:</p>
<p>https://github.com/axodotdev/oranda/releases/download/v0.0.3/oranda-npm-package.tar.gz</p>
<p>If you're cutting a stable release (not-prerelease), you can use the &quot;latest&quot; URL format:</p>
<p>https://github.com/axodotdev/oranda/releases/latest/download/oranda-npm-package.tar.gz</p>
<p>In the future we may <a href="https://github.com/axodotdev/cargo-dist/issues/245">introduce more streamlined CI-based publishing workflows</a>.</p>
<p><a href="installers/../reference/config.html#npm-scope">You can set the @scope the package is published under with the npm-scope cargo-dist config</a>.</p>
<p>We will otherwise do our best to faithfully translate <a href="https://doc.rust-lang.org/cargo/reference/manifest.html">any standard Cargo.toml values you set</a> to an equivalent in the npm package.json format (name, version, authors, description, homepage, repository, keywords, categories...).</p>
<p>The package will also include an npm-shrinkwrap.json file for the npm packages the installer uses, this is the same as package-lock.json but &quot;really for reals I want this to be respected even if it's installed into another project&quot;. Note that <a href="https://doc.rust-lang.org/cargo/commands/">cargo install similarly disrespects Cargo.lock unless you pass --locked</a>.</p>
<h2 id="limitations-and-caveats"><a class="header" href="#limitations-and-caveats">Limitations and Caveats</a></h2>
<ul>
<li>Requires a well-defined <a href="installers/../reference/artifact-url.html">artifact URL</a></li>
<li><a href="https://github.com/axodotdev/cargo-dist/issues/75">Cannot detect situations where musl-based builds are appropriate</a> (static or dynamic)</li>
<li><a href="https://github.com/axodotdev/cargo-dist/issues/226">Relies on nodejs's builtin gzip support to unpack the files, which only works with .tar.gz</a></li>
<li>Cannot run any kind of custom install logic</li>
</ul>
<p>As a result of the <code>.tar.gz</code> limitation, <code>cargo dist init</code> will prompt you to change <a href="installers/../reference/config.html#windows-archive">windows-archive</a> and <a href="installers/../reference/config.html#unix-archive">unix-archive</a> to &quot;.tar.gz&quot; if you enable the npm installer, erroring if you decline.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="homebrew-installer"><a class="header" href="#homebrew-installer">Homebrew Installer</a></h1>
<blockquote>
<p>since 0.2.0</p>
</blockquote>
<p>This provides a <a href="https://brew.sh">Homebrew</a> formula which allows users to <code>brew install</code> your package. Since it installs to a location on the user's <code>PATH</code>, it provides a simple and convenient installation method for users who already have Homebrew available. When published to a <a href="https://docs.brew.sh/Taps">tap</a> (package repository), this gives your users an easy way to both install your package and to keep it up to date using <code>brew update</code> and <code>brew upgrade</code>. It fetches the same prebuilt macOS binaries as the shell installer.</p>
<p>cargo-dist can, optionally, publish your formula to a tap repository for you on every release. To enable this, add a <code>tap</code> field to your <code>Cargo.toml</code> pointing to a GitHub repository that you control and add <code>homebrew</code> to the <code>publish-jobs</code> field. The repository name must start with <code>homebrew-</code>. For example:</p>
<pre><code class="language-toml">tap = &quot;axodotdev/homebrew-formulae&quot;
publish-jobs = [&quot;homebrew&quot;]
</code></pre>
<p>In order to write to a tap GitHub repository, cargo-dist needs a <a href="https://github.com/settings/tokens/new?scopes=repo">personal access token</a> with the <code>repo</code> scope exposed as <code>HOMEBREW_TAP_TOKEN</code>. For more information on GitHub Actions secrets, <a href="https://docs.github.com/en/actions/security-guides/encrypted-secrets">consult this documentation</a>.</p>
<p>Limitations/Caveats:</p>
<ul>
<li>Does not support creating a formula which builds from source</li>
<li>Does not support Linuxbrew (Homebrew on Linux)</li>
<li>Does not support <a href="https://github.com/axodotdev/cargo-dist/issues/309">Cask</a> for more convenient GUI app installation</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="msi-installer"><a class="header" href="#msi-installer">msi Installer</a></h1>
<blockquote>
<p>Since 0.3.0</p>
</blockquote>
<ul>
<li><a href="installers/msi.html#setup">Setup</a>
<ul>
<li><a href="installers/msi.html#setup-step-1-set-authors-in-your-cargotoml">Setup Step 1: set &quot;authors&quot; in your Cargo.toml</a></li>
<li><a href="installers/msi.html#setup-step-2-run-init-and-enable-msi">Setup Step 2: run init and enable &quot;msi&quot;</a></li>
<li><a href="installers/msi.html#setup-step-3-youre-done-time-to-test">Setup Step 3: you're done! (time to test)</a></li>
</ul>
</li>
<li><a href="installers/msi.html#how-it-works">How It Works</a></li>
<li><a href="installers/msi.html#advanced-usage">Advanced Usage</a>
<ul>
<li><a href="installers/msi.html#managed-advanced-usage">Managed Advanced Usage</a></li>
<li><a href="installers/msi.html#unmanaged-advanced-usage">Unmanaged Advanced Usage</a></li>
</ul>
</li>
</ul>
<p>This guide will walk you through setting up a <a href="installers/./index.html#bundling-installers">bundling</a> Windows msi installer. It assumes you've already done initial setup of cargo-dist, as described in <a href="installers/../way-too-quickstart.html">the way-too-quickstart</a>, and now want to add an msi to your release process.</p>
<p>(Just a bit of a warning, this stuff works but there's a few rough edges, please let us know if you run into any issues!)</p>
<h2 id="setup-1"><a class="header" href="#setup-1">Setup</a></h2>
<p>We'll start with the bare-minimum and then explain what we did and how to modify it afterwards.</p>
<h3 id="setup-step-1-set-authors-in-your-cargotoml"><a class="header" href="#setup-step-1-set-authors-in-your-cargotoml">Setup Step 1: set &quot;authors&quot; in your Cargo.toml</a></h3>
<p>msi requires you to specify a &quot;manufacturer&quot; for you application, which is by default sourced from the &quot;authors&quot; field in you Cargo.toml. <strong>If you don’t have that field set, the next step will error out.</strong> If you have an authors entry like <code>My Cool Company &lt;support@mycoolcompany.org&gt;</code> then the manufacturer will be &quot;My Cool Company&quot;.</p>
<h3 id="setup-step-2-run-init-and-enable-msi"><a class="header" href="#setup-step-2-run-init-and-enable-msi">Setup Step 2: run init and enable &quot;msi&quot;</a></h3>
<p>Rerun <code>cargo dist init</code> and when it prompts you to choose installers, enable &quot;msi&quot;.</p>
<p>Once init completes, some changes will be made to your project, <strong>check all of them in</strong>:</p>
<ol>
<li><code>installers = [&quot;msi&quot;]</code> will be added to <code>[workspace.metadata.dist]</code></li>
<li><code>[package.metadata.wix]</code> will be added to your packages with distable binaries. This is your msi-specific config. For now don't worry about it.</li>
<li><code>wix/main.wxs</code> will be created for each of your packages with distable binaries. This is a template for your msi. For now assume this file is completely managed by cargo-dist, and can't be hand-edited.</li>
</ol>
<h3 id="setup-step-3-youre-done-time-to-test"><a class="header" href="#setup-step-3-youre-done-time-to-test">Setup Step 3: you're done! (time to test)</a></h3>
<p>See <a href="installers/../way-too-quickstart.html#test-it-out">the quickstart's testing guide</a> for the various testing options.</p>
<p>If the above steps worked, <code>cargo dist plan</code> should now include an msi for each Windows platform you support.</p>
<p><code>cargo dist build</code> is a bit trickier. Not only do you have to be on Windows to get an msi built, you also need to have the <a href="https://wixtoolset.org/docs/wix3/">WiX v3 toolchain</a> installed (WiX v4 isn't yet supported). If you don't the build will just error out. In GitHub CI the WiX v3 toolchain is pre-installed, so using PR testing is recommended.</p>
<p>The resulting msi should include the following functionality:</p>
<ul>
<li>(optional) EULA dialog</li>
<li>A menu that lets you choose where to install and whether to add it to PATH
<ul>
<li>Default install location is <code>%ProgramFiles%\{app_name}\</code> (e.g. <code>C:\Program Files\axolotlsay\</code>)</li>
<li>Default is to add the install location to PATH</li>
<li>Currently the only files that will be included are the app's binaries in a <code>bin</code> subdir</li>
</ul>
</li>
<li>If rerun, you will get an uninstall/reinstall menu</li>
<li>If a newer version is run, it will automatically uninstall the old version</li>
<li>If an older version is run, it will report that a newer version is installed and exit</li>
<li>The application will appear in the Windows &quot;Add or remove programs&quot; menu and can be uninstalled from there</li>
</ul>
<p>Certain licenses in your Cargo.toml like &quot;Apache&quot; or &quot;MIT&quot; (but <em>not</em> dual MIT/Apache) will get an auto-generated EULA that's just agreeing to the software license -- we know, that's not how software licenses work, but people seem to like to do it. See the section on advanced usage for how to set a more useful EULA.</p>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h2>
<p>As you may suspect from the setup, we rely on the industry standard <a href="https://wixtoolset.org/docs/wix3/">WiX v3 toolchain</a> to generate your msi installers (WiX v4 isn't yet supported). The <code>main.wxs</code> format is its xml-based templating system. Some of the information about your app is baked into this template (binaries, descriptions, licenses...), while other information is sourced at build time (mostly the version).</p>
<p>If the template ever desyncs from the values it was generated from, commands like <code>cargo dist plan</code> (and therefore your pull request CI) will error out and ask you to rerun <code>cargo dist init</code> to regenerate it.</p>
<p>The values we added to <code>[package.metadata.wix]</code> are:</p>
<ul>
<li><code>upgrade-guid = &quot;SOME-RANDOM-GUID&quot;</code> (since 0.3.0)</li>
<li><code>path-guid = &quot;SOME-OTHER-RANDOM-GUID&quot;</code> (since 0.3.0)</li>
<li><code>license = false</code> (since 0.5.0)</li>
<li><code>eula = false</code> (since 0.5.0)</li>
</ul>
<p>The two GUIDs are used by Windows to determine that two MSIs with different versions refer to the same application and install location, which is required for it to properly handle things like upgrades. They are persisted in your Cargo.toml to keep them stable across regenerations of <code>main.wxs</code>.</p>
<p>The license/EULA settings are there to disable the auto-license/EULA feature of cargo-wix. That feature <em>would</em> look at your package's license and potentially turn it into a EULA agreement. While this is a thing some folks want, most of our users aren't interested in getting their end-users to &quot;agree to the MIT License&quot;. You can opt back into auto-EULAs by setting both of those to <code>true</code> (if you just delete the keys cargo-dist will keep adding them back as <code>false</code>).</p>
<p><strong>All of the logic for generating wxs files is part of <a href="https://volks73.github.io/cargo-wix/cargo_wix/">cargo-wix</a>, which cargo-dist includes as a library.</strong> It's a great project we happily contribute to, although some TLC is still needed to make the integration perfect (some of its warnings/errors may mention its own CLI's flags, and those sure won't work if you pass them to cargo-dist). The <code>[package.metadata.wix]</code> config is purely cargo-wix's, see <a href="https://volks73.github.io/cargo-wix/cargo_wix/">their docs for all the knobs it exposes</a>.</p>
<h2 id="advanced-usage"><a class="header" href="#advanced-usage">Advanced Usage</a></h2>
<p>There are two paths for advanced usage: managed and unmanaged. We recommend the managed approach, but the unmanaged approach is there for true power users.</p>
<h3 id="managed-advanced-usage"><a class="header" href="#managed-advanced-usage">Managed Advanced Usage</a></h3>
<p>If you want cargo-dist to be able to keep your <code>main.wxs</code> consistent with the definitions in your Cargo.tomls, then all you have available is the knobs exposed in <code>[package.metadata.wix]</code> -- see <a href="https://volks73.github.io/cargo-wix/cargo_wix/">cargo-wix's docs for details</a>.</p>
<h3 id="unmanaged-advanced-usage"><a class="header" href="#unmanaged-advanced-usage">Unmanaged Advanced Usage</a></h3>
<p>If you're not worried about keeping <code>main.wxs</code> consistent, then you can choose to dive deep into the full power of <a href="https://wixtoolset.org/docs/wix3/">WiX v3</a> by adding <code>allow-dirty = [&quot;msi&quot;]</code> to your cargo-dist config. Once you do this cargo-dist will stop trying to update it, and won't check if it's out of date.</p>
<p>At that point you can make whatever hand-edits you want to main.wxs, as long as you still use the variables that cargo-wix injects into the template at build-time for things like versions and binary paths.</p>
<p>See <a href="https://wixtoolset.org/docs/wix3/">WiX v3's docs</a> for all the things their format supports.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="artifacts"><a class="header" href="#artifacts">Artifacts</a></h1>
<p>cargo-dist exists to help you distribute your binaries, which involves generating a lot of different files which we call <em>Artifacts</em>. Archives are the baseline artifacts that contain your binaries, and installers are the fancy artifacts that make it easy to install or run the binaries.</p>
<ul>
<li><a href="artifacts/./archives.html">Archives</a>: tarballs/zips containing your binaries</li>
<li><a href="artifacts/../installers/index.html">Installers</a>: things that help fetch/install archives</li>
<li><a href="artifacts/./checksums.html">Checksums</a>: hashes of other artifacts</li>
<li><a href="artifacts/./symbols.html">Symbols</a>: debuginfo/symbols/sourcemaps of your binaries</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="archives"><a class="header" href="#archives">Archives</a></h1>
<p>Archives are the primary output of cargo-dist: a single file (zip or tarball) containing prebuilt executables/binaries for an app, along with additional static files like READMEs, LICENSEs, and CHANGELOGs. The docs previously referred to these as &quot;executable-zips&quot;, so if you ever see that term floating around, this is what's being talked about.</p>
<p>When you <a href="artifacts/../reference/concepts.html#defining-your-apps">tell us to build an app</a> for <a href="artifacts/../reference/config.html#targets">a platform</a> we will always make an archive for it.</p>
<p><a href="artifacts/../installers/index.html#fetching-installers">Fetching installers</a> will fetch and unpack archives from wherever you <a href="artifacts/../reference/artifact-url.html">uploaded them</a>. <a href="artifacts/../installers/index.html#bundling-installers">Bundling installers</a> will use an exact copy of the binary stored in the archive, but may differ on other included files.</p>
<h2 id="auto-detected-files"><a class="header" href="#auto-detected-files">Auto-Detected Files</a></h2>
<p>We will always auto-detect READMEs, LICENSES, and CHANGELOGs with the following logic (described more below):</p>
<ul>
<li>README: <a href="artifacts/../reference/config.html#readme">package.readme</a>, or find <code>README*</code></li>
<li>LICENSE: <a href="artifacts/../reference/config.html#license-file">package.license-file</a>, or find <code>LICENSE*</code>/<code>UNLICENSE*</code></li>
<li>CHANGELOG: find <code>CHANGELOG*</code>/<code>RELEASES*</code></li>
</ul>
<p>&quot;Find <code>XYZ*</code>&quot; means we will look for a file whose name starts with &quot;XYZ&quot; in the same directory as the Cargo.toml for a package that defines the app. If no such file is found, we will also search for it in the same directory as the workspace's Cargo.toml (so packages &quot;inherit&quot; these files from the workspace).</p>
<p>It is generally assumed that a directory only contains one of each kind of file. If multiple possible matches are in the same directory we will arbitrarily pick the first one we saw, so don't rely on that.</p>
<p>Auto-detected files are first and foremost <a href="artifacts/archives.html#archive-contents">auto-included into the archive</a>, however they can also be used for other things. For instance, the autodetected CHANGELOG is fed into our CHANGELOG features.</p>
<h2 id="archive-contents"><a class="header" href="#archive-contents">Archive Contents</a></h2>
<p>The &quot;root&quot; of an archive is either the actual root directory of the archive (zips); or a directory with the same name as the archive, but without the extension (tarballs). This difference is for compatibility/legacy reasons, and can be smoothed away by unpacking tarballs with tar's <code>--strip-components=1</code>.</p>
<p>An app's archive always includes its binaries at the root.</p>
<p>By default <a href="artifacts/archives.html#auto-detected-files">auto-detected files</a> for a package are auto-included into its archives at the root of the package. The <a href="artifacts/../reference/config.html#auto-includes">auto-includes</a> config controls this behaviour.</p>
<p>The <a href="artifacts/../reference/config.html#include">include</a> can be used to manually add specific files/directories to the root of the archive.</p>
<h2 id="archive-formats"><a class="header" href="#archive-formats">Archive Formats</a></h2>
<p>Archives can be zips or tarballs (gz, xz, or zstd).</p>
<p>By default we make .zip on windows and .tar.xz elsewhere, but this can be configured with <a href="artifacts/../reference/config.html#windows-archive">windows-archive</a> and <a href="artifacts/../reference/config.html#unix-archive">unix-archive</a> features.</p>
<h2 id="build-flags"><a class="header" href="#build-flags">Build Flags</a></h2>
<p>We currently <a href="artifacts/../workspaces/simple-guide.html#the-dist-profile">always build with <code>--profile=dist</code></a></p>
<p>By default we build with <code>--workspace</code> <a href="https://docs.rs/cargo-hakari/latest/cargo_hakari/about/index.html#what-are-workspace-hack-crates">to keep things consistent</a>, but this can be configured with the <a href="artifacts/../reference/config.html#precise-builds">precise-builds config</a> (see those docs for details on when precise-builds will be force-enabled).</p>
<p>By default we build your packages with default features, but this can be configured with the <a href="artifacts/../reference/config.html#features">features</a>, <a href="artifacts/../reference/config.html#default-features">default-features</a>, and <a href="artifacts/../reference/config.html#all-features">all-features</a> configs.</p>
<p>When targeting windows-msvc we will unconditionally <a href="https://rust-lang.github.io/rfcs/1721-crt-static.html">append &quot;-Ctarget-feature=+crt-static&quot;</a> to your RUSTFLAGS, which should just be the default for rustc but isn't for legacy reasons.</p>
<p>We don't really <a href="https://github.com/axodotdev/cargo-dist/issues/74">support cross-compilation</a>, but we'll faithfully attempt the compile by telling rustup to install the toolchain and passing <code>--target</code> to cargo as instructed -- it will probably just fail. On macOS cross-compiles between Intel and Apple Silicon will work. <a href="https://github.com/axodotdev/cargo-dist/issues/75">linux-musl is slated for a future version</a>.</p>
<h2 id="code-signing"><a class="header" href="#code-signing">Code Signing</a></h2>
<p>&quot;Code Signing&quot; is a very overloaded term, with wildly varying implementations that accomplish different goals. For instance, Linux users are currently very big on <a href="https://github.com/axodotdev/cargo-dist/issues/120">sigstore</a> as a fairly turn-key code signing solution, but <a href="https://github.com/axodotdev/cargo-dist/issues/21">neither Windows nor macOS</a> acknowledge its existence (and likely never will, as the benefits of sigstore completely defeat the stated purpose of code signing requirements on those platforms).</p>
<p>Roughly speaking, codesigning can be broken up into &quot;Is this app made by the developer?&quot; and &quot;Can I trust apps made by this developer?&quot;. Tools like sigstore are focused on the former, while Windows/macOS only care about the latter. They want you to pay some money and jump through administrative hoops. They also expect you to pay completely different groups and go through completely different hoops, so each platform requires a completely different solution.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="checksums"><a class="header" href="#checksums">Checksums</a></h1>
<p>By default cargo-dist will generate a matching checksum file for each <a href="artifacts/../artifacts/archives.html">archive</a> it generates. The default checksum is sha256, so for instance <code>my-app-x86_64-pc-windows-msvc.zip</code> will also come with <code>my-app-x86_64-pc-windows-msvc.zip.sha256</code> that tools like <code>sha256sum</code> can use. This can be configured with <a href="artifacts/../reference/config.html#checksum">the checksum config</a>.</p>
<p><a href="artifacts/../installers/index.html#fetching-installers">Fetching installers</a> can also use these checksums (or ones baked into them) to validate the integrity of the files they download. With https and unsigned checksums the security benefit is minimal, but it can catch more boring problems like data corruption.</p>
<p>The homebrew installer actually ignores your checksum setting and always uses sha256 hashes that are baked into it, as required by homebrew itself.</p>
<p>Updating the other fetching installers to use these checksums is <a href="https://github.com/axodotdev/cargo-dist/issues/439">still a work in progress</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="symbols"><a class="header" href="#symbols">Symbols</a></h1>
<p>This feature is currently disabled <a href="https://github.com/axodotdev/cargo-dist/issues/136">pending a rework</a>, but basically we want to save your debuginfo/symbols/sourcemaps in the form of pdbs, dSYMs, etc. This will automatically happen as a side-effect of building <a href="artifacts/./archives.html">archives</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ci"><a class="header" href="#ci">CI</a></h1>
<p>All of the <a href="ci/../introduction.html#distributing">distribute functionality</a> of cargo-dist depends on some kind of CI integration to provide things like <a href="ci/../reference/artifact-url.html">file hosting</a>, secret keys, and the ability to spin up multiple machines.</p>
<p>A CI backend can be enabled with <a href="ci/../reference/config.html#ci">the ci config</a>. cargo-dist's core CI job can be <a href="ci/../ci/customizing.html">customized</a> using several extra features.</p>
<h2 id="supported-ci-providers"><a class="header" href="#supported-ci-providers">Supported CI Providers</a></h2>
<ul>
<li><a href="ci/./github.html">github</a>: use GitHub Actions and uploads to GitHub Releases</li>
</ul>
<h2 id="a-quick-tour-of-the-ci-process"><a class="header" href="#a-quick-tour-of-the-ci-process">A quick tour of the CI process</a></h2>
<p>The CI process is divided into several stages which happen in order. Understanding these steps will help you follow the release process and, if necessary, debug failures.</p>
<ol>
<li>plan: cargo-dist calculates which builds to run, and which platforms to build for, and enumerates the files that builds are expected to produce. The output of this step is saved and shared between steps and is also included in the final release as <code>dist-manifest.json</code>.</li>
<li>build-local-artifacts: cargo-dist builds native binaries and produces tarballs.</li>
<li>build-global-artifacts: cargo-dist builds platform-independent artifacts such as installers.</li>
<li>host: cargo-dist decides whether to proceed with publishing a release and uploading artifacts.</li>
<li>publish: Artifacts are uploaded and, if used, the Homebrew formula is released.</li>
<li>announce: The release is created with its final non-draft contents.</li>
</ol>
<h2 id="future-ci-providers"><a class="header" href="#future-ci-providers">Future CI Providers</a></h2>
<p>The following CI providers have been requested, and we're open to supporting them, but we have no specific timeline for when they will be implemented. Providing additional info/feedback on them helps us prioritize the work:</p>
<ul>
<li><a href="https://github.com/axodotdev/cargo-dist/issues/48">gitlab</a></li>
<li><a href="https://github.com/axodotdev/cargo-dist/issues/273">travis</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="github-ci"><a class="header" href="#github-ci">GitHub CI</a></h1>
<blockquote>
<p>since 0.0.3</p>
</blockquote>
<ul>
<li><a href="ci/github.html#setup">Setup</a>
<ul>
<li><a href="ci/github.html#setup-step-1-set-repository-in-your-cargotoml">Setup Step 1: set &quot;repository&quot; in your Cargo.toml</a></li>
<li><a href="ci/github.html#setup-step-2-run-init-and-enable-github-ci">Setup Step 2: run init and enable GitHub CI</a></li>
<li><a href="ci/github.html#setup-step-3-youre-done-time-to-test">Setup Step 3: you're done! (time to test)</a></li>
</ul>
</li>
<li><a href="ci/github.html#advanced-usage">Advanced Usage</a>
<ul>
<li><a href="ci/github.html#build-and-upload-artifacts-on-every-pull-request">Build and upload artifacts on every pull request</a></li>
<li><a href="ci/github.html#bring-your-own-release">Bring your own release</a>
<ul>
<li><a href="ci/github.html#limitations">Limitations</a></li>
</ul>
</li>
<li><a href="ci/github.html#hand-editing-releaseyml">Hand-editing release.yml</a></li>
<li><a href="ci/github.html#fiddly-build-task-settings">Fiddly build task settings</a></li>
<li><a href="ci/github.html#checking-what-your-build-linked-against">Checking what your build linked against</a>
<ul>
<li><a href="ci/github.html#limitations-1">Limitations</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>The GitHub CI backend provides a &quot;Release&quot; Workflow that is triggered by pushing a tagged commit to your repository. It uses the tag to determine which packages you're trying to publish, and builds and uploads them to a GitHub Release.</p>
<h2 id="setup-2"><a class="header" href="#setup-2">Setup</a></h2>
<p>cargo-dist is currently very eager to setup the GitHub CI backend, so it's pretty easy to do! Most likely it was automatically setup the first time you ran <code>cargo dist init</code>. If you followed <a href="ci/../way-too-quickstart.html">the way-too-quickstart</a>, then you should also have it setup.</p>
<h3 id="setup-step-1-set-repository-in-your-cargotoml"><a class="header" href="#setup-step-1-set-repository-in-your-cargotoml">Setup Step 1: set &quot;repository&quot; in your Cargo.toml</a></h3>
<p>You probably already have it set, but if you don't, now's the time to do it. We need to know <a href="ci/../reference/artifact-url.html#github">the URL of your GitHub repository</a> for several features, and the next step will fail without it.</p>
<h3 id="setup-step-2-run-init-and-enable-github-ci"><a class="header" href="#setup-step-2-run-init-and-enable-github-ci">Setup Step 2: run init and enable GitHub CI</a></h3>
<p>Run <code>cargo dist init</code> on your project.</p>
<p>If you did the previous step, you should get prompted to &quot;enable Github CI and Releases?&quot;, with the default answer being &quot;yes&quot;. Choose yes.</p>
<p>You will also get prompted to &quot;check your release process in pull requests?&quot;, with the default answer being &quot;plan - run 'cargo dist plan' on PRs (recommended)&quot;. Choose that option.</p>
<p>Once init completes, some changes will be made to your project, <strong>check all of them in</strong>:</p>
<ul>
<li><code>ci = [&quot;github&quot;]</code> should be added to <code>[workspace.metadata.dist]</code></li>
<li><code>./github/workflows/release.yml</code> should be created, this is your Release Workflow</li>
</ul>
<h3 id="setup-step-3-youre-done-time-to-test-1"><a class="header" href="#setup-step-3-youre-done-time-to-test-1">Setup Step 3: you're done! (time to test)</a></h3>
<p>See <a href="ci/../way-too-quickstart.html#test-it-out">the quickstart's testing guide</a> for the various testing options.</p>
<p>The easiest testing option for this is to open a pull-request for everything you checked in -- it should run the <code>plan</code> step of your release CI as part of the PR.</p>
<h2 id="advanced-usage-1"><a class="header" href="#advanced-usage-1">Advanced Usage</a></h2>
<p>Here are some more advanced things you can do with GitHub CI.</p>
<h3 id="build-and-upload-artifacts-on-every-pull-request"><a class="header" href="#build-and-upload-artifacts-on-every-pull-request">Build and upload artifacts on every pull request</a></h3>
<blockquote>
<p>since 0.3.0</p>
</blockquote>
<p>By default, cargo-dist will run the plan step on every pull request but won't perform a full release build. If these builds are turned on, the resulting pull request artifacts won't be uploaded to a release but will be available as a download from within the CI job. To enable this, select the &quot;upload&quot; option from the &quot;check your release process in pull requests&quot; question in <code>cargo-dist-init</code> or set <a href="ci/../reference/config.html#pr-run-mode">the <code>pr-run-mode</code> key</a> to <code>&quot;upload&quot;</code> in <code>Cargo.toml</code>'s cargo-dist config. For example:</p>
<pre><code class="language-toml">pr-run-mode = &quot;upload&quot;
</code></pre>
<h3 id="bring-your-own-release"><a class="header" href="#bring-your-own-release">Bring your own release</a></h3>
<blockquote>
<p>since 0.2.0</p>
</blockquote>
<p>By default, cargo-dist will want to create its own GitHub Release and set the title/body with things like your CHANGELOG/RELEASES and some info about how to install the release. However if you have your own process for generating the contents of GitHub Release, we support that.</p>
<p>If you set <code>create-release = false</code> in your cargo-dist config, cargo-dist will assume a draft Github Release for the current git tag already exists with the title/body you want, and just upload artifacts to it. At the end of a successful publish it will undraft the GitHub Release for you.</p>
<h4 id="limitations"><a class="header" href="#limitations">Limitations</a></h4>
<ul>
<li>Currently, the only supported package managers are Apt (Linux), Chocolatey (Windows) and Homebrew (macOS).</li>
<li>GitHub currently only provides x86_64 macOS runners. When you request packages, the Intel versions will always be installed regardless of build targets. While Apple Silicon builds can use CLI tools installed this way, you will not be able to build software for Apple Silicon if it requires C libraries from Homebrew.</li>
</ul>
<h3 id="hand-editing-releaseyml"><a class="header" href="#hand-editing-releaseyml">Hand-editing release.yml</a></h3>
<blockquote>
<p>since 0.3.0</p>
</blockquote>
<p>The happy-path of cargo-dist has us completely managing release.yml, and since 0.3.0 we will actually consider it an error for there to be any edits or out of date information in release.yml.</p>
<p>If there's something that cargo-dist can't do that makes you want to hand-edit the file, we'd love to hear about it so that you can stay on the happy-path!</p>
<p>However we know you sometimes really need to do those hand-edits, so there is a way to opt into it. If you <a href="ci/../reference/config.html#allow-dirty">set <code>allow-dirty = [&quot;ci&quot;]</code> in your cargo-dist config</a>, cargo-dist will stop trying to update the file and stop checking if it's out of date.</p>
<p>Although you're not &quot;using cargo-dist wrong&quot; if you do this, <strong>be aware that you are losing access to a lot of the convenience and UX benefits of cargo-dist</strong>. Every piece of documentation that says &quot;just run cargo dist init&quot; may not work correctly, as a new feature may require the CI template to be updated. Even things as simple as &quot;updating cargo-dist&quot; will stop working.</p>
<p>We have put a lot of effort into minimizing those situations, with <code>plan</code> increasingly being responsible for dynamically computing what the CI should do, but that's not perfect, and there's no guarantees that future versions of cargo-dist won't completely change the way CI is structured.</p>
<h3 id="fiddly-build-task-settings"><a class="header" href="#fiddly-build-task-settings">Fiddly build task settings</a></h3>
<blockquote>
<p>since 0.0.1</p>
</blockquote>
<p>Here's a grab-bag of more random settings you probably don't want to use, but exist in case you need them.</p>
<p>By default cargo-dist lets all the build tasks keep running even if one of them fails, to try to get you as much as possible when things go wrong. <a href="ci/../reference/config.html#fail-fast"><code>fail-fast = true</code> can be set to disable this</a>.</p>
<p>By default cargo-dist breaks build tasks onto more machines than strictly necessary to create the maximum opportunities for concurrency and to increase fault-tolerance. For instance if you want to build for both arm64 macOS and x64 macOS, that <em>could</em> be done on the same machine, but we put it on two machines so they can be in parallel and succeed/fail independently. <a href="ci/../reference/config.html#merge-tasks"><code>merge-tasks = true</code> can be set to disable this</a>.</p>
<h3 id="checking-what-your-build-linked-against"><a class="header" href="#checking-what-your-build-linked-against">Checking what your build linked against</a></h3>
<blockquote>
<p>since 0.4.0</p>
</blockquote>
<p>Although most Rust builds are statically linked and contain their own Rust dependencies, some crates will end up dynamically linking against system libraries. It's useful to know what your software picked up—sometimes this will help you catch things you may not have intended, like dynamically linking to OpenSSL, or allow you to check for package manager-provided libraries your users will need to have installed in order to be able to run your software.</p>
<p>cargo-dist provides a linkage report during your CI build in order to allow you to check for this. For macOS and Linux, it's able to categorize the targets it linked against to help you gauge whether or not it's likely to cause problems for your users. To view this, check the detailed view of your CI build and consult the &quot;Build&quot; step from the <code>upload-local artifacts</code> jobs.</p>
<p>This feature is defined for advanced users; most users won't need to use it. It's most useful for developers with specialized build setups who want to ensure that their binaries will be safe for all of their users. A few examples of users who may need to use it:</p>
<ul>
<li>Users with custom runners with extra packages installed beyond what's included in the operating system;</li>
<li>Users who have installed extra packages using cargo-dist's system dependency feature;</li>
<li>Users whose cargo buildsystems include extra C dependencies.</li>
</ul>
<p>The report is divided into categories to help you make sense of where these libraries are from and what it might mean for your users. These categories are:</p>
<ul>
<li>System: Libraries that come with your operating system. On Linux, these packages are all provided by the system's package manager, and the linkage report includes information about which package includes each library. Some of these packages will be included in the base OS, and will be safe to rely on, while you'll need to ensure your users have others. If you're using standard base images like GitHub Actions's and haven't installed additional packages using apt, the packages in this list should be preinstalled for your users. On macOS, these packages are shipped with the operating system and not managed by a package manager; you can always rely on these being there within the same version of macOS.</li>
<li>Homebrew (macOS only): Libraries that are provided by the Homebrew package manager for macOS. These packages are not installed by default, so your users will need to have them installed in order to be able to use your software.</li>
<li>Public (unmanaged): Libraries which are present in public locations, but which are not managed or provided by the system or a package manager. Because these are not standard parts of the operating system, your users will be unlikely to have them.</li>
<li>Frameworks (macOS only): Frameworks, a special type of library provided by macOS. Frameworks installed in the <code>/System</code> directory come with the operating system and are available to all users.</li>
<li>Other: A catch-all category for any libraries which don't fall in the previous categories.</li>
</ul>
<p>Here's an example of what a linkage report looks like for a Linux binary;</p>
<pre><code>axolotlsay (x86_64-unknown-linux-gnu):

┌────────────────────┬─────────────────────────────────────────────────┐
│ Category           ┆ Libraries                                       │
╞════════════════════╪═════════════════════════════════════════════════╡
│ System             ┆ /lib/x86_64-linux-gnu/libgcc_s.so.1 (libgcc-s1) │
│                    ┆ /lib/x86_64-linux-gnu/libpthread.so.0 (libc6)   │
│                    ┆ /lib/x86_64-linux-gnu/libc.so.6 (libc6)         │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ Homebrew           ┆                                                 │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ Public (unmanaged) ┆                                                 │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ Frameworks         ┆                                                 │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ Other              ┆                                                 │
└────────────────────┴─────────────────────────────────────────────────┘
</code></pre>
<h4 id="limitations-1"><a class="header" href="#limitations-1">Limitations</a></h4>
<p>While the linkage report can be run locally, the report for Linux artifacts can only be run on Linux.</p>
<p>The Windows report is currently unable to provide information about the sources of libraries.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="customizing-ci"><a class="header" href="#customizing-ci">Customizing CI</a></h1>
<ul>
<li><a href="ci/customizing.html#install-extra-packages">Install extra packages</a></li>
<li><a href="ci/customizing.html#custom-jobs">Custom jobs</a></li>
</ul>
<p>cargo-dist's generated CI configuration can be extended in several ways: it can be configured to install extra packages before the build begins, and it's possible to add extra jobs to run at specific lifecycle moments.</p>
<p>In the past, you may have customized cargo-dist's generated CI configuration and used the <code>allow-dirty = [&quot;ci&quot;]</code> configuration option. With these new customization options, you may well not need to directly hand-edit cargo-dist's config any longer; we encourate migrating to these new tools.</p>
<h2 id="install-extra-packages"><a class="header" href="#install-extra-packages">Install extra packages</a></h2>
<blockquote>
<p>since 0.4.0</p>
</blockquote>
<p>Sometimes, you may need extra packages from the system package manager to be installed before in the builder before cargo-dist begins building your software. Cargo-dist can do this for you by adding the <code>dependencies</code> setting to your <code>Cargo.toml</code>. When set, the packages you request will be fetched and installed in the step before <code>build</code>. Additionally, on macOS, the <code>cargo build</code> process will be wrapped in <code>brew bundle exec</code> to ensure that your dependencies can be found no matter where Homebrew placed them.</p>
<p>Sometimes, you may want to make sure your users also have these dependencies available when they install your software. If you use a package manager-based installer, cargo-dist has the ability to specify these dependencies. By default, cargo-dist will examine your program to try to detect which dependencies it thinks will be necessary. At the moment, <a href="ci/../installers/homebrew.html">Homebrew</a> is the only supported package manager installer. You can also specify these dependencies manually.</p>
<p>For more information, see the <a href="ci/../reference/config.html#dependencies">configuration syntax</a>.</p>
<h2 id="custom-jobs"><a class="header" href="#custom-jobs">Custom jobs</a></h2>
<blockquote>
<p>since 0.3.0 (publish-jobs) and 0.7.0 (other steps)</p>
</blockquote>
<p>cargo-dist's CI can be configured to call additional jobs on top of the ones it has builtin. Currently, we support adding extra jobs to the the following list of steps:</p>
<ul>
<li><a href="ci/../reference/config.html#plan-jobs"><code>plan-jobs</code></a> (the beginning of the build process)</li>
<li><a href="ci/../reference/config.html#build-local-artifacts-jobs"><code>build-local-artifacts-jobs</code></a></li>
<li><a href="ci/../reference/config.html#build-global-artifacts-jobs"><code>build-global-artifacts-jobs</code></a></li>
<li>[<code>host-jobs</code>][config-host-jobs] (pre-publish)</li>
<li>[<code>publish-jobs</code>][config-publish-jobs]</li>
<li>[<code>post-announce-jobs</code>][config-post-announce] (after the release is created)</li>
</ul>
<p>Custom jobs have access to the plan, produced via the &quot;plan&quot; step. This is a JSON document containing information about the project, planned steps, and its outputs. It's the same format contained as the &quot;dist-manifest.json&quot; that will be included with your release. You can use this in your custom jobs to obtain information about what will be built. For more details on the format of this file, see the <a href="ci/../reference/schema.html">schema reference</a>.</p>
<p>To add a custom job, you need to follow two steps:</p>
<ol>
<li>Define the new job as a reusable workflow using the standard method defined by your CI system. For GitHub actions, see the documentation on <a href="https://docs.github.com/en/actions/using-workflows/reusing-workflows#creating-a-reusable-workflow">reusable workflows</a>.</li>
<li>Add the name of your new workflow file to the appropriate array in your <code>Cargo.toml</code>'s cargo-dist config, prefixed with a <code>./</code>. For example, if your job name is <code>.github/workflows/my-publish.yml</code>, you would write it like this:</li>
</ol>
<pre><code class="language-toml">publish-jobs = [&quot;./my-publish&quot;]
</code></pre>
<p>Here's an example reusable workflow written using GitHub Actions. It won't do any real publishing, just echo text to the CI output. First, create a file named <code>.github/workflows/publish-greeter.yml</code> with these contents:</p>
<pre><code class="language-yaml">name: Greeter

on:
  # Defining workflow_call means that this workflow can be called from
  # your main workflow job
  workflow_call:
    # cargo-dist exposes the plan from the plan step, as a JSON string,
    # to your job if it needs it
    inputs:
      plan:
        required: true
        type: string

jobs:
  greeter:
    runs-on: ubuntu-latest
    # This is optional; it exposes the plan to your job as an environment variable
    env:
      PLAN: ${{ inputs.plan }}
    steps:
      - name: Step 1
        run: |
          echo &quot;Hello!&quot;
          echo &quot;Plan is: ${PLAN}&quot;
</code></pre>
<p>Then, add the following to your <code>publish-jobs</code> array:</p>
<pre><code class="language-toml">publish-jobs = [&quot;./publish-greeter&quot;]
</code></pre>
<p>Running <code>cargo-dist init</code> for your tool will update your GitHub Actions configuration to make use of the new reusable workflow during the publish step.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guide"><a class="header" href="#guide">Guide</a></h1>
<p>The cargo-dist Guide is the &quot;beginner&quot; documentation that walks you through simple usage and then introduces more complex situations as you go. More advanced documentation can be found in &quot;<a href="workspaces/../reference/concepts.html">concepts</a>&quot;.</p>
<p>If you have a <a href="https://doc.rust-lang.org/cargo/reference/workspaces.html">Cargo Workspace</a> with a single Cargo package that <code>cargo install</code> works for, and just want zips containing prebuilt binaries for the major desktop platforms, that should Just Work as described in the <a href="workspaces/../way-too-quickstart.html">Way-Too-Quickstart</a>. Things get more complicated if you want to:</p>
<ul>
<li>have more packages in your <a href="https://doc.rust-lang.org/cargo/reference/workspaces.html">Cargo Workspace</a> (libraries, multiple binaries, ...)</li>
<li>have additional steps in your build (configure the system, add files, ...)</li>
<li>build various kinds of <a href="workspaces/../installers/index.html">installers</a> (curl-sh scripts, npm packages, msi, ...)</li>
</ul>
<p>Gonna be blunt and say that cargo-dist is still in early days and we still need to implement a lot of stuff to better support all the things people want to do with Shippable Builds. If what you want to do doesn't seem properly supported and we don't have <a href="https://github.com/axodotdev/cargo-dist/issues">an issue</a> for it, absolutely file one so we can hash it out!</p>
<p>The guide will start by explaining the simple case, and then explain the more complicated cases.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guide-a-simple-application"><a class="header" href="#guide-a-simple-application">Guide: A Simple Application</a></h1>
<ul>
<li><a href="workspaces/simple-guide.html#setup-and-updates">Setup (and Updates)</a>
<ul>
<li><a href="workspaces/simple-guide.html#the-dist-profile">The &quot;dist&quot; Profile</a></li>
<li><a href="workspaces/simple-guide.html#the-workspace-config">The Workspace Config</a></li>
<li><a href="workspaces/simple-guide.html#the-ci-script">The CI Script</a></li>
<li><a href="workspaces/simple-guide.html#finishing-setup">Finishing Setup</a></li>
</ul>
</li>
<li><a href="workspaces/simple-guide.html#cutting-releases">Cutting Releases</a>
<ul>
<li><a href="workspaces/simple-guide.html#release-notes">Release Notes</a></li>
</ul>
</li>
</ul>
<p>Let's start with the kind of simple <a href="https://doc.rust-lang.org/cargo/reference/workspaces.html">Cargo Workspace</a> you would get from <code>cargo new my-app</code> (or <code>cargo init my-app</code>): a single package that defines a <a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html#binaries">binary target</a>. This is exactly the situation the <a href="workspaces/../way-too-quickstart.html">Way-Too-Quickstart</a> should work perfectly for. Here we're going to take it a bit slower.</p>
<p>Our goal will be to setup a Github CI workflow that announces a new release of our application with a Github Release. The workflow will also build our application for the 3 major desktop platforms, wrap the binaries in zips/tarballs, and upload them to the Github Release. The Github Release's text will also include the relevant release notes from our RELEASES.md file.</p>
<p>The workflow will be triggered whenever you push a <a href="https://git-scm.com/book/en/v2/Git-Basics-Tagging">Git Tag</a> specifying the application's new version, like &quot;v1.0.0&quot;. Don't worry, you won't need to write those workflows yourself, cargo-dist will generate them for you!</p>
<blockquote>
<p>TO BE EXTREMELY PEDANTIC: The workflow will trigger whenever Github sees that the git tag <em>and</em> the commit it refers to are part of the repo <em>and</em> the timestamp(?) of both(?) is <em>after</em> the commit that introduced the workflow's yml file. That last part is an absolute headache, and may require you to delete the tag <em>both locally and on github</em> if you created it before the workflow. Basically, setup cargo-dist <em>before</em> you start cutting releases!</p>
</blockquote>
<h2 id="setup-and-updates"><a class="header" href="#setup-and-updates">Setup (and Updates)</a></h2>
<p>To setup cargo-dist on our project (after we've <a href="workspaces/../install.html">installed it</a>), we &quot;need&quot; to run <code>cargo dist init</code>, which will provide us with a series of interactive prompts and explanations to configure our project. The recommended option can always be selected by hitting ENTER, and you can automate that by just passing <code>--yes</code>.</p>
<p>You can rerun <code>init</code> as many times as you want, as it also functions as an &quot;update&quot; command for your config. This is especially convenient for updating your project to the version of cargo-dist you're running, as it will prompt you to do that whenever the versions don't match (refusing to proceed if declined).</p>
<pre><code class="language-sh">cargo dist init
</code></pre>
<p><a href="workspaces/../reference/cli.html#cargo-dist-init"><code>init</code></a> on its own just edits your Cargo.toml to include the recommended defaults. If you have enabled CI support, it will also run <code>cargo dist generate</code> after setting things up. This ensures your config and your CI scripts are in sync, but will unfortunately clobber any hand-edits you made to the scripts.</p>
<p>Let's look at those defaults that were added (yes those comments are generated too, you will never stop me from adding more docs!!!):</p>
<pre><code class="language-toml"># The profile that 'cargo dist' will build with
[profile.dist]
inherits = &quot;release&quot;
lto = &quot;thin&quot;

# Config for 'cargo dist'
[workspace.metadata.dist]
# The preferred cargo-dist version to use in CI (Cargo.toml SemVer syntax)
cargo-dist-version = &quot;0.0.6&quot;
# CI backends to support
ci = [&quot;github&quot;]
# The installers to generate for each app
installers = []
# Target platforms to build apps for (Rust target-triple syntax)
targets = [&quot;x86_64-unknown-linux-gnu&quot;, &quot;x86_64-apple-darwin&quot;, &quot;x86_64-pc-windows-msvc&quot;, &quot;aarch64-apple-darwin&quot;]
</code></pre>
<blockquote>
<p>If your config doesn't have <code>ci = [&quot;github&quot;]</code> by default, then you probably don't have <code>repository = &quot;https://github.com/...&quot;</code> consistently set in your Cargo.toml(s). The rest of this guide will assume you did. cargo-dist will work fine without it, you just won't get Github CI integration or <a href="workspaces/../installers/index.html">installers</a>.</p>
</blockquote>
<h3 id="the-dist-profile"><a class="header" href="#the-dist-profile">The &quot;dist&quot; Profile</a></h3>
<p>First let's talk about <code>[profile.dist]</code>. This is a custom <a href="https://doc.rust-lang.org/cargo/reference/profiles.html">Cargo Profile</a> that cargo-dist will use to build your app. If you want to, you can use it yourself by passing <code>--profile=dist</code> to cargo (i.e. <code>cargo run --profile=dist</code>). We define a separate profile from the normal &quot;release&quot; one so that you can be comfortable giving your Shippable Builds more aggressive settings without making local development too tedious.</p>
<p>In this case the default profile cargo-dist recommends is essentially the same as --release (hence <code>inherits = &quot;release&quot;</code>), but with <a href="https://doc.rust-lang.org/cargo/reference/profiles.html#lto">thin LTO</a> enabled (<code>lto = &quot;thin&quot;</code>). This will make the build take longer, but produce more optimized builds.</p>
<p>cargo-dist uses the existence of <code>[profile.dist]</code> in your Cargo.toml to detect if your project has been properly initialized, and will generally refuse to run other commands otherwise. Sorry but you can't delete the profile!</p>
<h3 id="the-workspace-config"><a class="header" href="#the-workspace-config">The Workspace Config</a></h3>
<p>Next let's talk about <code>[workspace.metadata.dist]</code>. Cargo allows other tools to include their own project-wide settings in this kind of <a href="https://doc.rust-lang.org/cargo/reference/workspaces.html#the-metadata-table">metadata table</a>. See <a href="workspaces/../reference/config.html">config</a> for the full set of options, but here we'll look at the defaults.</p>
<p><code>cargo-dist-version = &quot;0.0.6&quot;</code> is cargo-dist recording its own version in your config for the sake of reproducibility and documentation. When you run <a href="workspaces/../reference/cli.html#cargo-dist-generate">generate</a> the resulting CI scripts will use that version of cargo-dist.</p>
<p><code>ci = [&quot;github&quot;]</code> lets subsequent runs of <a href="workspaces/../reference/cli.html#cargo-dist-generate">generate</a> know what CI scripts to generate. Its presence also enables certain Github-specific features like generating the body for a Github Release and telling installers to fetch binaries from a Github Release. It will be enabled by default if you have <code>repository = &quot;https://github.com/...&quot;</code> consistently set in your Cargo.toml(s). (&quot;github&quot; is currently the only supported CI backend.)</p>
<p><code>installer = []</code> is just saying that we haven't enabled any <a href="workspaces/../installers/index.html">installers</a>. Installers are intentionally excluded here to keep this example focused.</p>
<p><code>targets = ...</code> is listing the <a href="https://doc.rust-lang.org/nightly/rustc/platform-support.html">platforms</a> to build your application for. In this case, because we didn't specify the targets with <code>--target</code>, <a href="workspaces/../reference/cli.html#cargo-dist-init">init</a> has selected the &quot;recommended desktop suite&quot;: &quot;x64 linux&quot;, &quot;x64 macos&quot;, &quot;x64 windows&quot;, and &quot;arm64 macos (Apple silicon)&quot;. In v0.0.6 these are the only properly supported choices, because we wanted to get the core of cargo-dist solid first. Future versions should hopefully introduce proper support for important targets like &quot;musl linux&quot;.</p>
<h3 id="the-ci-script"><a class="header" href="#the-ci-script">The CI Script</a></h3>
<p>Because we set <code>ci = [&quot;github&quot;]</code>, <a href="workspaces/../reference/cli.html#cargo-dist-init">init</a> invoked <a href="workspaces/../reference/cli.html#cargo-dist-generate">generate</a> for us. Creating the Github CI workflow we wanted at <code>.github/workflows/release.yml</code>. Rather than including the full text here, I'll just link <a href="https://github.com/axodotdev/cargo-dist/blob/main/.github/workflows/release.yml">cargo-dist's own release.yml</a>, because cargo-dist is self-hosting and has an extremely boring build/config that is basically equivalent to the one we're looking at in this example.</p>
<p>The first thing you might notice is that there's a <em>lot</em> of comments describing the script. As always: you will never stop me from writing more docs and shoving them in your face. Actually ok you <em>can</em> stop me because I need to write a lot of docs here and those comments are already decent docs. Feel free to peruse them to get a feel for it.</p>
<p>One thing I want to emphasize is that each job of the workflow essentially boils down to &quot;install cargo-dist, run cargo-dist exactly once, then upload the files it tells you to&quot;. Ideally this means you can run that one cargo-dist command and get the same things that CI produced!</p>
<p>Anyway, the CI totally does all the things we said it should! Yay!</p>
<h3 id="finishing-setup"><a class="header" href="#finishing-setup">Finishing Setup</a></h3>
<p>Now that we've run <code>cargo dist init</code>, all we need to do is commit the results and push them up:</p>
<pre><code class="language-sh">git add .
git commit -am &quot;wow cool new cargo-dist CI!&quot;
git push
</code></pre>
<p>Actually wait we should... probably test that we set things up properly? The devil's always in the details when it comes to CI, but we can do some initial checking of things with the <a href="workspaces/../reference/cli.html#cargo-dist-plan">plan</a> command:</p>
<pre><code class="language-sh">cargo dist plan
</code></pre>
<p><a href="workspaces/../reference/cli.html#cargo-dist-plan">plan</a> is the same as <a href="workspaces/../reference/cli.html#cargo-dist-build">build</a> but it doesn't actually <em>run</em> the build and defaults to reporting info for all platforms. This makes it ideal for asking cargo-dist about the full Announcement a CI run would produce.</p>
<p>If everything went right, you should see something like the following:</p>
<p><img src="workspaces/../img/simple-app-manifest.png" alt="The result of running the plan command, described below" />.</p>
<p>This output has two parts: &quot;analyzing workspace&quot; and &quot;announcing&quot;</p>
<p>&quot;analyzing workspace&quot; describes what cargo-dist found in your workspace. In this case there's a package called &quot;my-app&quot; with a <a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html#binaries">binary target</a> of the same name.</p>
<p>&quot;announcing v0.1.0&quot; tells us the tag that should be pushed to announce a release of the current workspace (&quot;v0.1.0&quot;). Underneath it we see that the announcement will include &quot;my-app 0.1.0&quot; as expected. Underneath that we see 4 artifacts will be produced and uploaded:</p>
<ul>
<li>The Intel macOS build: my-app-v0.1.0-x86_64-apple-darwin.tar.xz</li>
<li>The M1 macOS build: my-app-v0.1.0-aarch64-apple-darwin.tar.xz</li>
<li>The Windows build: my-app-v0.1.0-x86_64-pc-windows-msvc.zip</li>
<li>The Linux build: my-app-v0.1.0-x86_64-unknown-linux-gnu.tar.xz</li>
</ul>
<p>It also helpfully lists the contents of each zip. In this case I didn't properly setup my project at all, so it only contains a prebuilt binary. If I actually add files like README.md, LICENSE, and RELEASES.md, cargo-dist will helpfully pick those up and include them (disable this with the <code>auto-includes=false</code> <a href="workspaces/../reference/config.html">config</a>):</p>
<p><img src="workspaces/../img/simple-app-manifest-with-files.png" alt="The same as the last screenshot, but now the files mentioned above are included in each zip/tarball" /></p>
<p>If you add <code>--output-format=json</code> you'll get a full machine-readable output instead, and have locally recreated the first step of the generate CI!</p>
<h2 id="cutting-releases"><a class="header" href="#cutting-releases">Cutting Releases</a></h2>
<p>With all our one-time setup done, we're ready to cut a release! This can be streamlined a lot with <a href="https://github.com/crate-ci/cargo-release">cargo-release</a> which will do essentially everything we're about to go through with a single command (<a href="workspaces/./cargo-release-guide.html">see the guide on that</a>), but it's helpful to understand the actual steps in case cargo-release doesn't fit your usecase or if you need to debug issues.</p>
<p>The first step is to do all the things you would do to prep a release: update docs, update release notes, bump version numbers in Cargo.tomls, run tests, and so on.</p>
<p>At this point we're confident and want to release things for real. Once again, we can check what cargo-dist thinks should happen with the <a href="workspaces/../reference/cli.html#cargo-dist-plan">plan</a> command:</p>
<pre><code class="language-sh">cargo dist plan
</code></pre>
<p>Similarly you can check that <code>cargo publish</code> will work with the <code>--dry-run</code> flag:</p>
<pre><code class="language-sh">cargo publish --dry-run
</code></pre>
<p>If both of those seem happy, you're ready to release! All we need to do is push up a commit that has the <a href="https://git-scm.com/book/en/v2/Git-Basics-Tagging">Git Tag</a> that <a href="workspaces/../reference/cli.html#cargo-dist-plan">plan</a> suggested. As we've seen in previous sections, it's recommending &quot;v0.1.0&quot; for our example app, so let's use that:</p>
<pre><code class="language-sh"># Publish to a Github Release with cargo-dist
git commit -am &quot;Chore: Release 0.1.0&quot;
git tag &quot;v0.1.0&quot;
git push
git push --tags

# Publish to crates.io
cargo publish
</code></pre>
<p>and that's... it! If everything's working, your CI should spin up a &quot;Release&quot; workflow that cargo-dist generated for you, and after a few minutes the &quot;Releases&quot; section of your repo should have all the results populated with something like this:</p>
<p><img src="workspaces/../img/simple-github-release.png" alt="A Github Release for &quot;my-app 0.1.0&quot; with shell-script installers and tarballs of prebuilt binaries" /></p>
<p>Oops! There's some extra features in that screenshot that I haven't explained yet! This includes the &quot;Release Notes&quot; feature and a few <a href="workspaces/../installers/index.html">installers</a>. Since we're talking about Releasing, let's talk about Release Notes.</p>
<h3 id="release-notes"><a class="header" href="#release-notes">Release Notes</a></h3>
<p>If your project has a top-level RELEASES/CHANGELOG file like &quot;RELEASES.md&quot;, then cargo-dist will automatically try to use it as part of your Announcement (Github Release). We use the <a href="https://github.com/taiki-e/parse-changelog">parse-changelog</a> library to try to find a heading for the version you're releasing, and if we do, we add it to the Github Release's text. We also use the heading as the title for the Github Release (rather than just the git tag).</p>
<p>Roughly speaking, the library is looking for something like:</p>
<pre><code class="language-text"># &lt;ignorable prefix&gt; &lt;version&gt; &lt;ignorable suffix&gt;
</code></pre>
<p>For instance in <code># Version 1.0.0 (2022-03-01)</code>, the only really important part is the &quot;1.0.0&quot;, which should exactly match the Cargo version of your package. If you want to see how your RELEASES/CHANGELOG file is interpreted you can install parse-changelog as a CLI and run it on the file to see what it thinks. In the future we'll have some better debugging tools for this.</p>
<p>If you're publishing a Version with some prerelease bits like &quot;1.0.0-prerelease.1&quot;, then we'll first look for that exact match in your RELEASES/CHANGELOG. If we can't find it we'll strip the prerelease/build suffix (in this case going back to &quot;1.0.0&quot;) and check for that. If <em>that</em> finds a match we'll edit the heading to include the prerelease suffix when we include it in the Announcement. This lets you have a stable heading like <code># Version 1.0.0 (under development)</code>, and prereleases will get headings like <code># Version 1.0.0-prerelease.1 (under development)</code>.</p>
<p>If none of the previous rules apply, &quot;1.0.0-prerelease.1&quot; will also match a special &quot;Unreleased&quot; heading (i.e. &quot;# Unreleased&quot;), which will get rewritten to &quot;# Version 1.0.0-prerelease.1&quot;. This lets you maintain a changelog for a pending release without having to commit to what version it will be.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guide-more-complex-workspaces"><a class="header" href="#guide-more-complex-workspaces">Guide: More Complex Workspaces</a></h1>
<ul>
<li><a href="workspaces/workspace-guide.html#multiple-binaries-in-one-package">Multiple Binaries In One Package</a></li>
<li><a href="workspaces/workspace-guide.html#multiple-packages-in-a-workspace">Multiple Packages In A Workspace</a></li>
<li><a href="workspaces/workspace-guide.html#announcement-tags">Announcement Tags</a></li>
<li><a href="workspaces/workspace-guide.html#singular-library-hack">Singular Library Hack</a></li>
<li><a href="workspaces/workspace-guide.html#using-cargo-release">Using cargo-release</a></li>
</ul>
<p>Now that we've <a href="workspaces/./simple-guide.html">looked at a simple example</a> with <code>cargo new</code>, let's start looking at ways to make a <a href="https://doc.rust-lang.org/cargo/reference/workspaces.html">Cargo Workspace</a> more complicated, and how cargo-dist will deal with them.</p>
<p>But first, let's define some precise terminology:</p>
<p>Rust projects typically exist as a single <em><a href="https://doc.rust-lang.org/cargo/reference/workspaces.html">Workspace</a></em>, which is a collection of one or more <em><a href="https://doc.rust-lang.org/cargo/appendix/glossary.html#package">Packages</a></em> that are all developed in the same repository (<a href="https://crates.io/">crates.io</a> dependencies are not considered part of the workspace). A workspace always has a root Cargo.toml where certain workspace-global settings are defined.</p>
<p>If the root Cargo.toml <em>doesn't</em> define a Package then we say it's a <em><a href="https://doc.rust-lang.org/cargo/reference/workspaces.html#virtual-workspace">Virtual Workspace</a></em>. A Virtual Workspace puts all the packages on the same level, treating them as equals. If you don't use a Virtual Workspace you are essentially saying the entire project exists to produce that one root Package. Both approaches make sense in different contexts. I personally prefer virtual workspaces because it makes cargo (and other tools) default to operating on all packages at once, which is usually what I want (e.g. I want <code>cargo test</code> to test the entire workspace, I want <code>cargo fmt</code> to format the whole workspace, and so on).</p>
<p>A <em><a href="https://doc.rust-lang.org/cargo/appendix/glossary.html#package">Package</a></em> is the thing defined by a Cargo.toml (except for the root Cargo.toml of a Virtual Workspace, which defines no package). Many people reasonably assume &quot;Package&quot; and &quot;Crate&quot; are synonyms -- after all you host your Packages on a website called &quot;<a href="https://crates.io/">crates.io</a>&quot;! As it turns out, this is not the case: a Package can in fact define multiple Crates at the same time.</p>
<p>A <em><a href="https://doc.rust-lang.org/book/ch07-01-packages-and-crates.html">Crate</a></em> is the actual unit of compilation that <em>rustc</em> thinks about, like a single library or binary. For the purposes of cargo-dist, you don't really need a perfect understanding of what is or isn't a &quot;crate&quot;. The important takeaway is that a single Package can contain multiple things that are conflated with a single unified name and version. As we'll see, this can be useful.</p>
<h2 id="multiple-binaries-in-one-package"><a class="header" href="#multiple-binaries-in-one-package">Multiple Binaries In One Package</a></h2>
<p>So here's where the difference between a &quot;Package&quot; and a &quot;Crate&quot; is most relevant: <a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html#binaries">Cargo lets a single Package define multiple binaries</a>. See those docs for all the details. This can be convenient if you want to produce a single logical application that provides a suite of CLIs. For instance, you might want to make a standalone &quot;my-tool&quot; CLI that can be invoked as <code>cargo my-tool</code> as well. The easiest way to do this is to define a second &quot;cargo-my-tool&quot; binary as part of the &quot;my-tool&quot; Package. Once you do, <code>cargo install my-tool</code> will install both!</p>
<p>cargo-dist tries to respect this semantic. If you define multiple binaries in a Package, we will treat the Package as one &quot;Application&quot; and bundle both binaries in all zips and <a href="workspaces/../installers/index.html">installers</a> for that App. There is no way to override this behaviour -- if you don't want two binaries to be considered part of the same App, you should use separate Packages.</p>
<h2 id="multiple-packages-in-a-workspace"><a class="header" href="#multiple-packages-in-a-workspace">Multiple Packages In A Workspace</a></h2>
<p>Alright here's where things get a bit more complicated and you need to make a decision on how exactly you plan to develop and release the packages that make up your project. Up until now we've been assuming you have a single package in your workspace, but now we're going to deal with more.</p>
<p>How cargo-dist interprets multiple packages is actually fairly simple:</p>
<ul>
<li>Each Package that defines binaries is considered an &quot;App&quot; with completely independent zips/installers</li>
<li>Each Package that doesn't define binaries is wholly irrelevant and ignored</li>
</ul>
<p>If a Package defines binaries but you want cargo-dist to ignore it just like it does with library-only packages (i.e. because the binaries are for local testing), you can do that with either:</p>
<ul>
<li><a href="workspaces/../reference/config.html#publish"><code>publish = false</code> in that Package's Cargo.toml</a></li>
<li><a href="workspaces/../reference/config.html#dist"><code>dist = false</code> in that Package's <code>[package.metadata.dist]</code></a></li>
</ul>
<p>Now here's the really important question you need to answer: <strong>how do you want to announce new versions of your packages?</strong></p>
<h2 id="announcement-tags"><a class="header" href="#announcement-tags">Announcement Tags</a></h2>
<blockquote>
<p>See <a href="workspaces/./cargo-release-guide.html">the guide on using cargo-dist with cargo-release for more detailed documentation of how to tag your commits in various workspace configurations</a>!</p>
</blockquote>
<p>When you push a Git Tag to your repository, cargo-dist's CI will try to create a single Announcement (A Github Release) for that tag. When you only have one Package that's a completely unambiguous operation. When you have multiple Packages we now need some way to disambiguate what you actually meant.</p>
<p>1 Git Tag = 1 cargo-dist Announcement = 1 Github Release</p>
<p>cargo-dist supports two forms of Announcement which you can select with the format of your Git Tag:</p>
<ul>
<li>Unified Announcement: VERSION selects all packages with the given version (v1.0.0, 0.1.0-prerelease.1, releases/1.2.3, ...)</li>
<li>Singular Announcement: PACKAGE-VERSION or PACKAGE/VERSION selects only the given package (my-app-v1.0.0, my-app/1.0.0, release/my-app/v1.2.3-alpha, ...)</li>
</ul>
<blockquote>
<p>People love their different tag formats, so we do our best to parse lots
of different kinds! Prefixing the version with <code>v</code> is optional. Anything
that comes before a <code>/</code> is ignored unless it's exactly a package name
(so <code>really/cool/5.0.0/releases/v1.0.0</code> is just read as &quot;1.0.0&quot;). Note
that something like &quot;1.0&quot; is not a valid <a href="https://docs.rs/semver/latest/semver/struct.Version.html#errors">Cargo SemVer Version</a>.</p>
</blockquote>
<p>These two modes support the following workflows:</p>
<ul>
<li>Releasing a workspace with only one App (either mode works but Unified is Best)</li>
<li>Releasing a workspace where all Apps are versioned in lockstep (Unified)</li>
<li>Releasing an individual App in a workspace with its own independent versioning (Singular)</li>
<li>Releasing several Apps in a workspace at once, but all independently (Push multiple Singular tags at once)</li>
</ul>
<blockquote>
<p>NOTE: Although you <em>could</em> use extremely careful versioning in conjunction with Unified Announcements to release a weird subset of the packages in your workspace, you really <em>shouldn't</em> because the Github Releases will be incoherent (v0.1.0 has these random packages, v0.2.0 has these other random packages... huh?), and you're liable to create painful tag collisions.</p>
</blockquote>
<p><strong>The need for a coherent Announcement Tag is so important that cargo-dist commands like &quot;build&quot; and &quot;manifest&quot; will error out if one isn't provided and it can't be guessed.</strong> If that happens you may need to pass an explicit <code>--tag=...</code> flag to disambiguate. Being this strict helps catch problems before you push to CI.</p>
<h2 id="singular-library-hack"><a class="header" href="#singular-library-hack">Singular Library Hack</a></h2>
<p>Normally cargo-dist will error out if the Announcement Tag selects no Apps, because it exists to build and distribute Apps and you just asked it to do nothing (which is probably a mistake). This would however create annoying CI errors if you just wanted to tag releases for your libraries.</p>
<p>For 0.0.3 I opted for this kind of weird half-functionality:</p>
<p><strong>cargo-dist will produce a very minimal build-less Announcement (and therefore Github Release) if you explicitly request a Singular Announcement that matches a library-only package</strong>. This feature is kind of half-baked, please let us know what you want to happen in this situation!</p>
<p>We'll probably have to add a config for specifying whether you want libraries to get Announcements or not when you push a singular tag for them.</p>
<h2 id="using-cargo-release"><a class="header" href="#using-cargo-release">Using cargo-release</a></h2>
<p>See <a href="workspaces/./cargo-release-guide.html">the dedicated guide to using cargo-release with cargo-dist</a>, which covers all sorts of nasty workspaces (it's also just a more useful in-depth look at ).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-cargo-release-1"><a class="header" href="#using-cargo-release-1">Using cargo-release</a></h1>
<ul>
<li><a href="workspaces/cargo-release-guide.html#cargo-release-basics">cargo-release Basics</a></li>
<li><a href="workspaces/cargo-release-guide.html#cargo-release-advanced-usage">cargo-release Advanced Usage</a></li>
<li><a href="workspaces/cargo-release-guide.html#one-package">One Package</a></li>
<li><a href="workspaces/cargo-release-guide.html#virtual-workspace-with-independent-versions">Virtual Workspace With Independent Versions</a>
<ul>
<li><a href="workspaces/cargo-release-guide.html#using-slash-in-tag-prefix-with-cargo-release">Using slash in tag prefix with cargo-release</a></li>
</ul>
</li>
<li><a href="workspaces/cargo-release-guide.html#virtual-workspace-with-unified-versions">Virtual Workspace With Unified Versions</a></li>
<li><a href="workspaces/cargo-release-guide.html#non-virtual-workspace-with-unified-versions">Non-Virtual Workspace With Unified Versions</a></li>
<li><a href="workspaces/cargo-release-guide.html#non-virtual-workspace-with-totally-independent-versions">Non-Virtual Workspace With Totally Independent Versions</a></li>
<li><a href="workspaces/cargo-release-guide.html#non-virtual-workspace-with-independent-libraries">Non-Virtual Workspace With Independent Libraries</a></li>
<li><a href="workspaces/cargo-release-guide.html#library-only-workspaces">Library-only Workspaces</a></li>
<li><a href="workspaces/cargo-release-guide.html#previewing-your-release">Previewing Your Release</a></li>
<li><a href="workspaces/cargo-release-guide.html#using-cargo-release-with-pull-requests">Using cargo-release with Pull Requests</a></li>
</ul>
<blockquote>
<p>NOTE: It will be helpful to read <a href="workspaces/./workspace-guide.html#announcement-tags">the section on cargo-dist Announcement Tags</a>, because that is the interface boundary between cargo-release and cargo-dist. TL;DR: cargo-dist interprets a git tag of &quot;v1.0.0&quot; as &quot;Announce/Release the whole workspace&quot; (Unified Announcement) and &quot;my-app-v1.0.0&quot; or &quot;my-app/v1.0.0&quot; as &quot;Announce/Release that one package&quot; (Singular Announcement).</p>
</blockquote>
<blockquote>
<p>NOTE: this guide assumes you're running <a href="https://github.com/crate-ci/cargo-release/releases/tag/v0.22.0">cargo-release v0.22.0</a> or greater, as that version made several significant changes to default behaviours (for the better!).</p>
</blockquote>
<p>cargo-dist intentionally doesn't handle these steps of cutting a release for you:</p>
<ul>
<li>updating the versions of your packages</li>
<li>writing your release notes</li>
<li>committing the results</li>
<li>tagging your commits</li>
<li>pushing to your repo</li>
<li>publishing to crates.io</li>
</ul>
<p>There's a lot of different workflows for these things and we're happy to leave that to you. All cargo-dist cares about is that a tagged commit eventually ends up in your repo (and that the format of that commit reflects the versions/names in your Cargo.tomls).</p>
<p>That said, you might find <a href="https://github.com/crate-ci/cargo-release">cargo-release</a> useful because it can handle all of the above things for you in a single command like <code>cargo release 1.0.0</code>. This section is dedicated to explaining how to use cargo-release with cargo-dist in various situations.</p>
<h2 id="cargo-release-basics"><a class="header" href="#cargo-release-basics">cargo-release Basics</a></h2>
<blockquote>
<p>NOTE: cargo-release will never do anything side-effectful unless you also pass it <code>--execute</code>. Unless otherwise specified, we are discussing the behaviour when that flag is passed, but will be omitting it for safety/brevity.</p>
</blockquote>
<p>In <a href="workspaces/./simple-guide.html">a simple project</a> with one package, without any configuration set for cargo-release, the command <code>cargo release 1.0.0</code> is roughly sugar for:</p>
<pre><code class="language-sh">&lt;does some basic checks for uncommitted files and upstream being ahead&gt;
&lt;edits your Cargo.toml to have version 1.0.0&gt;
git commit -am &quot;chore: Release my-app version 1.0.0&quot;
git tag v1.0.0
cargo publish
git push --atomic &lt;remote-branch&gt; refs/tags/v1.0.0
</code></pre>
<p>(The <code>git push --atomic</code> is basically a more robust version of <code>git push &amp;&amp; git push --tags</code>)</p>
<p>Hey neat that's basically everything I listed at the start of this section! And the tag format is exactly what cargo-dist expects for <a href="workspaces/./simple-guide.html">a simple project</a>!! What a coincidence!!! 😸</p>
<p>If you don't want some of these behaviours, you can disable them permanently with <code>[workspace.metadata.release]</code> in your Cargo.toml, or disable temporarily with CLI flags. See the <a href="https://github.com/crate-ci/cargo-release/blob/master/docs/reference.md">cargo-release reference</a> for all the details but here's some important ones to only get a subset of the behaviours:</p>
<ul>
<li>Don't want to publish? Set <code>publish = false</code> in the config or pass <code>--no-publish</code></li>
<li>Don't want to push? Set <code>push = false</code> in the config or pass <code>--no-push</code></li>
<li>Don't want to tag? Set <code>tag = false</code> in the config or pass <code>--no-tag</code></li>
</ul>
<p>See <a href="workspaces/cargo-release-guide.html#using-cargo-release-with-pull-requests">this section for specific details on using cargo-release with github pull requests (PRs)</a>.</p>
<p>Note also that you can use <code>[package.metadata.release]</code> to set configs on individual packages and not the whole workspace.</p>
<h2 id="cargo-release-advanced-usage"><a class="header" href="#cargo-release-advanced-usage">cargo-release Advanced Usage</a></h2>
<p>With <a href="workspaces/./workspace-guide.html">a more complex project/workspace</a>, cargo-release won't work as well out of the box with cargo-dist. To understand why, we need to understand the rules it applies consistently that can be strange if unexpected.</p>
<p>When you run <code>cargo release</code> <strong>it should follow the same rules cargo does for selecting the subset of the workspace to operate on</strong>. That is, if you were to run <code>cargo test</code>, the packages that actually get tested are the same ones that <code>cargo release</code> will attempt to release! I'll try to briefly summarize (imperfectly, workspaces can get really Complicated):</p>
<ul>
<li>When run in the subdirectory of a package, execution is scoped to that package</li>
<li>When run in the root of a <a href="https://doc.rust-lang.org/cargo/reference/workspaces.html#virtual-workspace">virtual workspace</a> (where the root Cargo.toml isn't an actual package), execution applies to all packages</li>
<li>When run in the root of a non-virtual workspace (where the root Cargo.toml is probably the &quot;main&quot; package that all other packages exist to implement), execution <strong>only applies to the root package</strong>.</li>
<li>When run with <code>--workspace</code>, execution applies to all packages (good for making a non-virtual workspace behave more like a virtual one).</li>
<li>Specific packages can be selected with <code>-p</code>/<code>--package</code></li>
<li>I haven't checked if cargo-release respects <a href="https://doc.rust-lang.org/cargo/reference/workspaces.html#the-default-members-field">default-members</a> but that's a thing too!</li>
</ul>
<p><strong>By default, cargo-release will create a separate git tag for every package it's releasing.</strong> The default format of these tags depends on the shape of your workspace:</p>
<ul>
<li>If there is a root package (the workspace is non-virtual), releases of the root package will be tagged as <code>v{VERSION}</code> (&quot;v1.0.0&quot;).</li>
<li>All other packages will be tagged <code>{PACKAGE_NAME}-v{VERSION}</code> (&quot;my-app-v1.0.0&quot;)</li>
</ul>
<p>As we'll see below, these combined behaviours have the following interactions with cargo-dist:</p>
<ul>
<li>✅ one package workspace: tags it like &quot;v1.0.0&quot;</li>
<li>✅ virtual workspace, independent versions: tags each package like &quot;my-app-v1.0.0&quot;</li>
<li>✅ virtual workspace, independent versions: tags each package like &quot;my-app/v1.0.0&quot; (needs additional configuration in cargo-release, see below)</li>
<li>❌ virtual workspace, unified versions: we want a single tag like &quot;v1.0.0&quot;</li>
<li>❌ non-virtual workspace: it will mix the tag formats, which <em>might</em> be ok in one situation</li>
</ul>
<p>Now let's dig into each of these situations in more detail.</p>
<h2 id="one-package"><a class="header" href="#one-package">One Package</a></h2>
<p>TLDR: cargo-release Just Works.</p>
<pre><code class="language-sh">cargo release 1.0.0
</code></pre>
<hr />
<p>As stated previously, cargo-release works great with cargo-dist if you have <a href="workspaces/./simple-guide.html">a simple project</a> consisting of a single package (the kind of project <code>cargo new my-app</code> or <code>cargo init my-app</code> will create).</p>
<p>See the previous sections for what this will do and how to configure the behaviour if, e.g. you want to hold off on publishing to crates.io or pushing.</p>
<p>The more general version of this situation -- where you have one root package and all the other workspace members are libraries that exist to implement it -- has two possible solutions depending on how you want to version/release the libraries:</p>
<ul>
<li><a href="workspaces/cargo-release-guide.html#non-virtual-workspace-with-unified-versions">version/release the libraries in lockstep</a></li>
<li><a href="workspaces/cargo-release-guide.html#non-virtual-workspace-with-independent-libraries">version/release the libraries separately</a></li>
</ul>
<h2 id="virtual-workspace-with-independent-versions"><a class="header" href="#virtual-workspace-with-independent-versions">Virtual Workspace With Independent Versions</a></h2>
<p>TLDR: cargo-release just needs you to specify which package to release.</p>
<pre><code class="language-sh">cargo release -p my-package 1.0.0
</code></pre>
<hr />
<p>If you have a <a href="https://doc.rust-lang.org/cargo/reference/workspaces.html#virtual-workspace">virtual workspace</a> (one where the root Cargo.toml isn't an actual package) and want everything in the workspace to be versioned/released independently, then cargo-dist will default to operating on all your packages at once, and you should do the same thing you would do if you were running <code>cargo publish</code>: either use <code>-p</code> to select the relevant packages or <code>cd</code> into the subdir of that package before running the command.</p>
<p>Each tag will induce cargo-dist to produce an independent Announcement (Github Release) for that package.</p>
<p>If the package is a library the Github Release won't have any builds/artifacts uploaded. <a href="workspaces/./workspace-guide.html#singular-library-hack">See here for details</a>.</p>
<p>Note that we currently don't support finding/emitting Release Notes for Singular Releases (simply haven't had time to design and implement it yet).</p>
<h3 id="using-slash-in-tag-prefix-with-cargo-release"><a class="header" href="#using-slash-in-tag-prefix-with-cargo-release">Using slash in tag prefix with cargo-release</a></h3>
<p>For cargo-release to work with tag prefixes that use a slash, you must configure it to use a different prefix for tags in <code>Cargo.toml</code>.</p>
<p>For a virtual workspace, put the following in your root Cargo.toml:</p>
<pre><code class="language-toml">[workspace.metadata.release]
tag-prefix = &quot;{{crate_name}}/&quot;
</code></pre>
<p>Please refer to <a href="https://github.com/crate-ci/cargo-release/blob/master/docs/reference.md#configuration">the cargo-release reference</a> for further information on how you can configure cargo-release.</p>
<h2 id="virtual-workspace-with-unified-versions"><a class="header" href="#virtual-workspace-with-unified-versions">Virtual Workspace With Unified Versions</a></h2>
<p>TLDR: cargo-release just needs you to specify that versioning/tagging should be unified.</p>
<pre><code class="language-toml"># Add this config to your root Cargo.toml (virtual manifest)
[workspace.metadata.release]
shared-version = true
tag-name = &quot;v{{version}}&quot;
</code></pre>
<pre><code class="language-sh">cargo release 1.0.0
</code></pre>
<hr />
<p>If you have a <a href="https://doc.rust-lang.org/cargo/reference/workspaces.html#virtual-workspace">virtual workspace</a> (one where the root Cargo.toml isn't an actual package) and want everything in the workspace to be versioned/released in lockstep with a single Unified Announcement (One Big Github Release), then you're going to need to configure cargo-release as above.</p>
<p>After that it works perfectly, and cargo-release will even automagically handle publishing your packages to crates.io in the right sequence and waiting for the publishes to propagate before running the next one (no more &quot;oops sorry the package you just published isn't actually propagated to the registry yet so the package that depends on it can't be published&quot;).</p>
<p>(See the next section on non-virtual workspaces with unified versions for some grittier details on what's going on here.)</p>
<h2 id="non-virtual-workspace-with-unified-versions"><a class="header" href="#non-virtual-workspace-with-unified-versions">Non-Virtual Workspace With Unified Versions</a></h2>
<p>TLDR: this is much the same as the virtual workspace case <strong>but you need to pass --workspace on the CLI</strong>.</p>
<pre><code class="language-toml"># Add this config to your root Cargo.toml (virtual manifest)
[workspace.metadata.release]
shared-version = true
tag-name = &quot;v{{version}}&quot;
</code></pre>
<pre><code class="language-sh">cargo release 1.0.0 --workspace
</code></pre>
<hr />
<p>If you have a non-virtual workspace (one where the root Cargo.toml is a package) and want everything in the workspace to be versioned/released in lockstep with a single Unified Announcement (One Big Github Release), then it's <em>almost</em> the same as the virtual case (see the previous section).</p>
<p>The one caveat is that cargo-dist is consistent to a fault here, and even though we've explicitly told it things should be versioned/tagged in lockstep, <strong>running it in the root of your project still only releases the root package</strong>, and that's not what you want!</p>
<p>We need to tell it that we <em>really</em> meant it and pass <code>--workspace</code>!</p>
<p>What's happening here is that <code>cargo-release</code> is conceptually defined to run on each package individually, with just the &quot;git push&quot; step being unified. The tagging settings we're providing work because it's basically repeatedly going &quot;oh hey I was already going to make that tag, no need to make it again&quot;. It doesn't have a proper notion of the entire workspace being released in perfect lockstep, so if you ask it to release only some of the packages it will happily oblige.</p>
<p>In the virtual workspace this Just Works because commands in the root directory are implicitly <code>--workspace</code>.</p>
<h2 id="non-virtual-workspace-with-totally-independent-versions"><a class="header" href="#non-virtual-workspace-with-totally-independent-versions">Non-Virtual Workspace With Totally Independent Versions</a></h2>
<p>TLDR: this is a more complicated mess because but you <em>probably</em> want to make the root package have the Singular Announcement format, and then you just need to be explicit about each package you want to release on the CLI:</p>
<pre><code class="language-toml"># Add this config to your root Cargo.toml (main package)
[package.metadata.release]
tag-name = &quot;{{crate_name}}-v{{version}}&quot;
</code></pre>
<pre><code class="language-sh">cargo release -p my-package 1.0.0
</code></pre>
<hr />
<p>If you have a non-virtual workspace (one where the root Cargo.toml is a package) and want everything in the workspace to be versioned/released independently, then the simplest approach is to make everything behave like it does in the <a href="workspaces/cargo-release-guide.html#virtual-workspace-with-independent-versions">Virtual Workspace With Independent Versions</a>.</p>
<p>However if you find yourself in this position it's likely that your workspace actually looks like:</p>
<ul>
<li>root package is The One Application this project exists to develop</li>
<li>all other packages are libraries that support it</li>
</ul>
<p>In this <em>precise</em> configuration you may be able to avoid configuration by adopting a hybrid &quot;Partially Independent Versions&quot; approach as described in the next section.</p>
<h2 id="non-virtual-workspace-with-independent-libraries"><a class="header" href="#non-virtual-workspace-with-independent-libraries">Non-Virtual Workspace With Independent Libraries</a></h2>
<p>TLDR: technically this Just Works but you need to be specific about what packages you're publishing and may have annoying issues in the future.</p>
<pre><code class="language-sh">cargo release -p my-package 1.0.0
</code></pre>
<hr />
<p>So if your workspace looks like this:</p>
<ul>
<li>root package is The One Application this project exists to develop</li>
<li>all other packages are libraries that support it</li>
</ul>
<p>Whenever you <code>cargo release</code> the root package, it will get tagged without a prefix (&quot;v1.0.0&quot;) and cargo-dist will create a Unified Announcement. Even though there are other packages in the workspace, cargo-dist will take this in stride because as far as it's concerned <strong>this looks exactly the same as a workspace with one package</strong>. Which is to say, it's no different from <a href="workspaces/./simple-guide.html">a simple project</a> as far as cargo-dist is concerned.</p>
<p>Whenever you <code>cargo release</code> a library, it will get tagged with a prefix (&quot;my-lib-v1.0.0&quot;) and cargo-dist will create a minimal Singular Announcement. <a href="workspaces/./workspace-guide.html#singular-library-hack">See here for details</a>. In future versions we might change this default (or at least make it configurable).</p>
<p>I have some vague concerns that this will be wonky if you ever introduce a second application to the workspace, but honestly that's probably going to be true regardless of if you were using cargo-dist, so maybe it's fine? Really I just don't trust non-virtual workspaces...</p>
<h2 id="library-only-workspaces"><a class="header" href="#library-only-workspaces">Library-only Workspaces</a></h2>
<p>cargo-dist really isn't designed for this but technically you can use the <a href="workspaces/./workspace-guide.html#singular-library-hack">Singular Library Trick</a> if you want. If you want cargo-dist to properly support this, please let us know!</p>
<h2 id="previewing-your-release"><a class="header" href="#previewing-your-release">Previewing Your Release</a></h2>
<p>cargo-release defaults to dry-run semantics, only doing side-effectful operations if you pass it <code>--execute</code>. It will also do its best to detect problems early and error out if things seem wrong. This absolutely rules!</p>
<p>There are two things to keep in mind:</p>
<ul>
<li>cargo-release's dry-run is imperfect and has some differences from the real run</li>
<li>cargo-release isn't aware of cargo-dist, so it can't check if what it's about to do will blow up in CI or not</li>
</ul>
<p>Let's start with the dry-run differences. I don't know them all but the <em>biggest</em> one that I hit is that it doesn't fully emulate bumping the versions in your Cargo.tomls. Notably when it checks if <code>publish</code> will work, it's building the current version of the packages. If your build is aware of its own version this can cause/miss problems (and you'll see funky stuff like &quot;Upgrading my-app from 1.0.0 to 2.0.0&quot; ... &quot;Packaging my-app 1.0.0&quot;).</p>
<p>As for being aware of cargo-dist... I want to design some features for this, but I'm not quite sure what it should look like yet.</p>
<p>I think in the short-term, the best I can offer you is &quot;make a temporary git branch and tell cargo-release to --execute but not push/tag/publish, then ask cargo-dist what it thinks extremely manually&quot;. A rough sketch:</p>
<pre><code class="language-sh"># make a temp branch where we can mess stuff up
git checkout -b tmp-release

# ask cargo-release what it thinks should happen
# (substitute the actual cargo-release command you'd use here)
cargo release 1.0.0
</code></pre>
<p>That should end with a line that looks like &quot;Pushing main, v1.0.0 to origin&quot;. The first item is the branch it's pushing to, all the following items are all the tags it wants to push. Now that we know the tags, we can ask cargo-release to update the package versions and then ask cargo-dist what it thinks of those tags:</p>
<pre><code class="language-sh"># just bump versions
cargo release 1.0.0 --execute --no-push --no-tag --no-publish

# ask cargo-dist what should be produced for the given tag
cargo dist plan --tag=&lt;tag-you-want-to-check&gt;
</code></pre>
<p>If that runs successfully and prints out the artifacts you expect, that's pretty good sign running cargo-release For Real will work! (You can also try <code>cargo dist build</code> if you're worried about the actual build failing.)</p>
<h2 id="using-cargo-release-with-pull-requests"><a class="header" href="#using-cargo-release-with-pull-requests">Using cargo-release with Pull Requests</a></h2>
<blockquote>
<p>In this section we will be using <code>$BRANCH</code> and <code>$VERSION</code> as placeholders for the branch you make your PR on and the version you want to release.</p>
</blockquote>
<p>Many teams have policies that prevent pushing to main, and require you to open pull requests instead. This conflicts with the <em>default</em> behaviour of cargo-release, but it works fine with some extra flags to encourage it to defer the steps until later. Specifically, use the following to &quot;partially&quot; run cargo-release:</p>
<pre><code class="language-sh">cargo release --no-publish --no-tag --allow-branch=$BRANCH $VERSION
</code></pre>
<p>The release process then has the following steps:</p>
<ul>
<li>step 0: create a new branch for the PR</li>
<li>step 1: &lt; finalize things like changelogs and commit &gt;</li>
<li>step 2: <strong>partially</strong> run <code>cargo release ...</code> to update your Cargo.tomls and push your branch</li>
<li>step 3: &lt; open a pr, review, merge &gt;</li>
<li>step 4: <strong>fully</strong> run <code>cargo release</code> on main to complete the process (publish and tag)</li>
</ul>
<p>Crucially, neither invocation of <code>cargo release</code> will modify your main branch directly. Step 4 will only push a git tag for the commit that is already on main.</p>
<p>Here's what this looks in practice:</p>
<pre><code class="language-sh"># step 0: make a branch
git checkout -b $BRANCH


# step 1: update things like the changelog
# &lt; edit some files or whatever here &gt;
git commit -am &quot;prep release&quot;


# step 2: have cargo-release handle tedious mechanical stuff
# this will:
#  * do some safety checks like &quot;git index is clean&quot;
#  * update version numbers in your crates (and handle inter-dependencies)
#  * git commit -am &quot;chore: release $NAME $VERSION&quot; (one commit for the whole workspace)
#  * git push (remember we're on a branch)
cargo release --no-publish --no-tag --allow-branch=$BRANCH $VERSION


# step 3: open a PR and review/merge to main
# NOTE: the above steps will result in two commits
#       we recommend using github's &quot;merge and squash&quot; feature to clean up
# ...


# step 4: remove the shackles from cargo release and RUN ON MAIN
# this will:
#  * tag the commit
#  * push the tag
#  * publish all crates to crates.io (handles waiting for dep publishes to propagate)
#  * trigger cargo-dist when it sees the tag (if applicable)
# THIS WON'T CREATE NEW COMMITS
#
# running &quot;cargo dist plan&quot; is totally optional, but this is is the best time to check
# that your cargo-dist release CI will produce the desired result when you push the tag
git checkout main
git pull
cargo dist plan
cargo release
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference"><a class="header" href="#reference">Reference</a></h1>
<p>The following sections are more focused on precise details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concepts"><a class="header" href="#concepts">Concepts</a></h1>
<ul>
<li><a href="reference/concepts.html#defining-your-apps">Defining Your Apps</a></li>
<li><a href="reference/concepts.html#defining-your-artifacts">Defining Your Artifacts</a></li>
<li><a href="reference/concepts.html#announcements-selecting-apps">Announcements (Selecting Apps)</a></li>
<li><a href="reference/concepts.html#artifact-modes-selecting-artifacts">Artifact Modes (Selecting Artifacts)</a>
<ul>
<li><a href="reference/concepts.html#all-artifacts-mode">All Artifacts Mode</a></li>
<li><a href="reference/concepts.html#global-artifacts-mode">Global Artifacts Mode</a></li>
<li><a href="reference/concepts.html#local-artifacts-mode">Local Artifacts Mode</a></li>
<li><a href="reference/concepts.html#host-artifacts-mode">Host Artifacts Mode</a></li>
</ul>
</li>
<li><a href="reference/concepts.html#putting-it-all-together">Putting It All Together</a></li>
</ul>
<p>Here's the section where I use a bunch of Capitalized Words to indicate they are a Special Concept in cargo-dist as I try to explain how it works. These are the &quot;advanced&quot; docs of cargo-dist; see <a href="reference/../workspaces/index.html">the guide</a> for the &quot;beginner&quot; docs.</p>
<p>An invocation of cargo-dist has 4 major inputs:</p>
<ul>
<li>The structure of your project's <a href="https://doc.rust-lang.org/cargo/reference/workspaces.html">Cargo Workspace</a> (via <a href="https://doc.rust-lang.org/cargo/commands/cargo-metadata.html">cargo-metadata</a>)</li>
<li>The config in your Cargo.toml <code>[workspace.metadata.dist]</code> (and <code>[package.metadata.dist]</code>)</li>
<li>The &quot;announcement tag&quot; (e.g. <code>--tag=v1.0.0</code>)</li>
<li>The &quot;artifact mode&quot; (e.g. <code>--artifacts=all</code>)</li>
</ul>
<p>The first two define the full &quot;Universe&quot; of your project -- the platforms/binaries/<a href="reference/../installers/index.html">installers</a> that cargo-dist wants to build. The second two tell cargo-dist what subset of the Universe to actually bother with.</p>
<p>It's important to the structure of cargo-dist that every invocation is aware of the full Universe and how it's being subsetted, because for instance if you want a shell script installer that does platform detection and fetches binaries, it needs to know about all the binaries/platforms it has to select from, even if this <em>particular</em> run of cargo-dist won't build them all!</p>
<p>First let's look at how cargo-dist computes the Universe.</p>
<h1 id="defining-your-apps"><a class="header" href="#defining-your-apps">Defining Your Apps</a></h1>
<p>Each Cargo package in your workspace that has <a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html#binaries">binary targets</a> is considered an App by cargo-dist. cargo-dist exists to build Apps, so making sure you and it agree on is important! (We prefer &quot;App&quot; over &quot;package&quot; because we want the freedom to one day decouple the two concepts -- for now they are strictly equivalent.)</p>
<p>Most invocations of cargo-dist will start by printing out a brief summary of the Apps that cargo-dist has found:</p>
<p><img src="reference/../img/workspace-log.png" alt="screenshot of the debug log, described below" /></p>
<p>The summary includes a list of every package in your workspace. If that package defines binaries, they will be listed underneath the package. If the package's listing is greyed out, that means cargo-dist has decided it's either Not An App or that it's not part of the current Announcement (<a href="reference/concepts.html#announcements-selecting-apps">see the Announcement section</a>), along with a parenthetical reason for its rejection, such as: &quot;no binaries&quot;, &quot;publish = false&quot;, &quot;dist = false&quot;, or &quot;didn't match tag&quot;.</p>
<p>In the above example the available Apps are &quot;evil-workspace&quot;, &quot;many-bin&quot;, and &quot;third-bin&quot;. &quot;many-bin&quot; defines two binaries, while the other two Apps only define one.</p>
<p>To match cargo-install's behaviour, if a package defines multiple binaries then they will be considered part of the same App and zips/<a href="reference/../installers/index.html">installers</a> for it will contain/install all of them. We figure if you went out of your way to have multiple binaries under one package (as opposed to separate packages for each), you did that for a reason! If you don't want that, make separate packages. There is currently no way to group multiple packages into a single App, although there probably will be one day.</p>
<p>If you don't want a package-with-binaries to be considered an App that cargo-dist should care about, you can use Cargo's own builtin <a href="https://doc.rust-lang.org/cargo/reference/manifest.html#the-publish-field">publish = false</a>. You can also use <code>dist = false</code> or <code>dist = true</code> in <a href="reference/../reference/config.html#dist">cargo-dist's own config</a>, which when defined will take priority over <code>publish</code>.</p>
<p>Things like <a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html#library">cdylibs</a> are not picked up by cargo-dist, even though they're similar to binaries. If anyone has a usecase for this we're happy to consider it (<a href="https://github.com/rust-lang/cargo/issues/6313">although there's some messy issues around Cargo clobbering itself when you define two many things under one package</a>).</p>
<h1 id="defining-your-artifacts"><a class="header" href="#defining-your-artifacts">Defining Your Artifacts</a></h1>
<p>Ok so you've defined your App, but what should we actually build for it? Let's look at what <code>cargo dist init --ci=github --installer=shell --installer=powershell --yes</code> dumps into your root Cargo.toml:</p>
<pre><code class="language-toml"># Config for 'cargo dist'
[workspace.metadata.dist]
# The preferred cargo-dist version to use in CI (Cargo.toml SemVer syntax)
cargo-dist-version = &quot;0.0.3&quot;
# CI backends to support
ci = [&quot;github&quot;]
# The installers to generate for each app
installers = [&quot;shell&quot;, &quot;powershell&quot;]
# Target platforms to build apps for (Rust target-triple syntax)
targets = [&quot;x86_64-unknown-linux-gnu&quot;, &quot;x86_64-apple-darwin&quot;, &quot;x86_64-pc-windows-msvc&quot;, &quot;aarch64-apple-darwin&quot;]

# The profile that 'cargo dist' will build with
[profile.dist]
inherits = &quot;release&quot;
lto = &quot;thin&quot;
</code></pre>
<p>The parts we're really interested in here are &quot;installers&quot;, &quot;targets&quot;, and <code>[profile.dist]</code>.</p>
<p>First the easy part: <code>profile.dist</code> is the profile cargo-dist will build everything with. We define a separate profile from <code>release</code> so that it can be tuned more aggressively for builds that are longer or more resource-intensive without making it tedious to develop locally.</p>
<p>The other 3 fields are defining the various Artifacts that should be produced for each App in the workspace (because this is <code>[workspace.metadata]</code> and not <code>[package.metadata]</code>).</p>
<p>For each entry in <code>targets</code> you will get a build of your App for <a href="https://doc.rust-lang.org/nightly/rustc/platform-support.html">that platform</a> in the form of an <a href="reference/../artifacts/archives.html">archive</a>.</p>
<p>For each entry in <code>installers</code> you get that kind of <a href="reference/../installers/index.html">installer</a> for your App. There are two classes of installer: &quot;global&quot; and &quot;local&quot;. This will be explained further in <a href="reference/concepts.html#artifact-modes-selecting-artifacts">the section on artifact modes</a>, but the tl;dr is that &quot;global&quot; installers are one-per-App while &quot;local&quot; installers are one-per-platform-per-app, similar to a <a href="https://docs.github.com/en/actions/using-jobs/using-a-matrix-for-your-jobs">Github CI Matrix</a>.</p>
<p>&quot;shell&quot; and &quot;powershell&quot; are both global installers. There aren't currently any implemented local installers, but those would be things like a windows &quot;msi&quot; or macos &quot;dmg&quot;, where you ostensibly want individual installers for each architecture.</p>
<h1 id="announcements-selecting-apps"><a class="header" href="#announcements-selecting-apps">Announcements (Selecting Apps)</a></h1>
<p>cargo-dist's self-generated CI is triggered by pushing git tags with specific formats like &quot;v1.0.0&quot;, &quot;my-app-v1.0.0&quot; or &quot;my-app/v1.0.0&quot;. Each tag will trigger its own independent run of that CI workflow. That tag defines the subset of the workspace (what packages) we want to produce a single unified Announcement for (i.e. a single Github Release). Every invocation of cargo-dist in that CI run will be passed that git tag with the <code>--tag</code> flag to ensure consensus on what to Announce (and therefore build and upload).</p>
<p>1 Git Tag = 1 cargo-dist Announcement = 1 Github Release</p>
<p>Even when not running in CI, this concept of a coherent Announcement Tag is important enough that we will always try to guess one even if none is provided. The &quot;build&quot;, &quot;manifest&quot;, and &quot;plan&quot; commands will refuse to run if a coherent Announcement Tag can't be determined to help you catch problems before you start pushing to CI. If this happens you will get a printout telling you some options:</p>
<p><img src="reference/../img/announcement-error.png" alt="the error printout, described below" /></p>
<p>Here we have the same workspace we saw in the <a href="reference/concepts.html#defining-your-apps">&quot;defining your apps&quot; section</a>, but we get a complaint from <code>cargo dist manifest</code>:</p>
<blockquote>
<p>There are too many unrelated apps in your workspace to coherently Announce!</p>
<p>Please either specify --tag, or give them all the same version</p>
</blockquote>
<p><strong>This introduces the one big rule for Announcements: all the Apps being Announced together have to agree on their Version.</strong> We need something to tie the announcement together and &quot;3 random Apps with different Versions&quot; has nothing to use! You should really just have 3 separate Announcements for those Apps. If you disagree, please let us know!</p>
<p>The error goes on to recommend the two formats for the Announcement Tag:</p>
<ul>
<li>Unified Announcement: VERSION selects all packages with the given version (v1.0.0, 0.1.0-prerelease.1, releases/1.2.3, ...)</li>
<li>Singular Announcement: PACKAGE-VERSION or PACKAGE/VERSION selects only the given package (my-app-v1.0.0, my-app/1.0.0, release/my-app/v1.2.3-alpha, ...)</li>
</ul>
<p>These two modes support the following workflows:</p>
<ul>
<li>Releasing a workspace with only one App (either mode works but Unified is Cleaner)</li>
<li>Releasing a workspace where all Apps are versioned in lockstep (Unified)</li>
<li>Releasing an individual App in a workspace with its own independent versioning (Singular)</li>
<li>Releasing several Apps in a workspace at once, but all independently (Push multiple Singular tags at once)</li>
</ul>
<p>In this case the error notes two valid Unified Announcements:</p>
<blockquote>
<p><code>--tag=v0.5.0</code> will Announce: evil-workspace, third-bin
<code>--tag=v0.7.6</code> will Announce: many-bin</p>
</blockquote>
<p>This tells us that evil-workspace and third-bin actually already agree on their Version. If we <em>do</em> want a Unified Announcement, we probably want to bring many-bin into agreement, or mark it as publish=false or dist=false.</p>
<p>Although you <em>could</em> use extremely careful versioning in conjunction with Unified Announcements to release a weird subset of the packages in your workspace, you really <em>shouldn't</em> because the Github Releases will be incoherent (v0.1.0 has these random packages, v0.2.0 has these other random packages... huh?), and you're liable to create painful tag collisions.</p>
<p>Normally cargo-dist will error out if the Announcement Tag selects no Apps, because it exists to build and distribute Apps and you just asked it to do nothing (which is probably a mistake). This would however create annoying CI errors if you just wanted to tag Individual Releases for your libraries. To make this more pleasant, <strong>cargo-dist will produce a very minimal build-less Announcement (and therefore Github Release) if you explicitly request a Singular Announcement that matches a library-only package</strong>. This feature is kind of half-baked, please let us know what you want to happen in this situation!</p>
<h1 id="artifact-modes-selecting-artifacts"><a class="header" href="#artifact-modes-selecting-artifacts">Artifact Modes (Selecting Artifacts)</a></h1>
<p>Now that we have a coherent Announcement and therefore have selected what apps we want to Release, we need to select what artifacts we want to build (or get a manifest for). Enumerating the exact artifacts for each invocation of cargo-dist would be tedious and error-prone, so we provide the <code>--artifacts=...</code> flag to specify the <em>Artifact Mode</em>, which is a certain subset of the Universe of all Artifacts:</p>
<ul>
<li>&quot;local&quot;: artifacts that are per-target platform (<a href="reference/../artifacts/archives.html">archives</a>, symbols, msi installers...)</li>
<li>&quot;global&quot;: artifacts that are one-per-app (shell installer, npm package...)</li>
<li>&quot;all&quot;: both global and local (so the whole Universe)</li>
<li>&quot;host&quot;: the default mode that kind of breaks the rules to let you test things out locally</li>
</ul>
<p>Let's ignore &quot;host&quot; mode for a bit and focus on the other three. Each one of these is intended to be used for specific tasks.</p>
<h2 id="all-artifacts-mode"><a class="header" href="#all-artifacts-mode">All Artifacts Mode</a></h2>
<p>The &quot;all&quot; Artifact Mode is largely intended for the <code>manifest</code> command, to get a listing of everything that would be produced if you were to push the given tag to CI. Here we check what v0.5.0 would produce for our favourite example workspace:</p>
<pre><code class="language-sh">cargo dist manifest --tag=v0.5.0 --artifacts=all --no-local-paths
</code></pre>
<p><img src="reference/../img/human-manifest-all.png" alt="A listing of the various Artifacts that should be produced" /></p>
<p>If we add <code>--output-format=json</code> we will get the <code>dist-manifest.json</code> that CI uploads to your Github Release:</p>
<pre><code class="language-sh">cargo dist manifest --tag=v0.5.0 --artifacts=all --no-local-paths --output-format=json
</code></pre>
<p>This is the only way that CI uses the flag, but you could also use &quot;all&quot; with <code>build</code> (the default cargo-dist command) if you want to get all the artifacts built at once, although you should probably filter the <code>--target</code>s as discussed in the section on &quot;local&quot;.</p>
<p><code>cargo dist manifest --artifacts=all --no-local-paths</code> is so useful/common that we provide an alias for it: <code>cargo dist plan</code>. The above can be simplified to:</p>
<pre><code class="language-sh">cargo dist plan --tag=v0.5.0
</code></pre>
<pre><code class="language-sh">cargo dist plan --tag=v0.5.0 -ojson
</code></pre>
<h2 id="global-artifacts-mode"><a class="header" href="#global-artifacts-mode">Global Artifacts Mode</a></h2>
<p>The &quot;global&quot; Artifact Mode allows you to unambiguously create a task that will build all the Artifacts for your Apps that <em>aren't</em> platform-specific and therefore only need to be made once per App:</p>
<pre><code class="language-sh">cargo dist build --tag=v0.5.0 --artifacts=global --no-local-paths
</code></pre>
<p><img src="reference/../img/global-build.png" alt="A global build producing only shell and powershell installers" /></p>
<p>Here we see that it only results in the &quot;shell&quot; and &quot;powershell&quot; installers getting built. The code to generate these should be totally cross-platform, so any runner is suitable for the task. The CI creates one &quot;global&quot; task that uses linux because that's the fast/cheap one.</p>
<h2 id="local-artifacts-mode"><a class="header" href="#local-artifacts-mode">Local Artifacts Mode</a></h2>
<p>The &quot;local&quot; Artifact Mode allows you to unambiguously create a task that will build all the Artifacts for your Apps that <em>are</em> platform-specific and therefore should have a copy made for every target platform.</p>
<p>If you just use this flag bare, cargo-dist <em>will</em> respect the request and try to build for all platforms at once... and this will probably fail, because cross-compilation is hard. Each &quot;local&quot; run should generally use <code>--target</code> to filter down the set of all supported targets to the ones you can confidently build on the current machine (<code>rustc -vV</code> will tell you the &quot;host&quot; target platform if you're not sure).</p>
<p>In my case it's &quot;x86_64-pc-windows-msvc&quot;, so let's try that:</p>
<pre><code class="language-sh">cargo dist build --tag=v0.5.0 --artifacts=local --target=x86_64-pc-windows-msvc --no-local-paths
</code></pre>
<p><img src="reference/../img/local-build.png" alt="A local build producing only archives for the current platform" /></p>
<p>Note that you can pass <code>--target</code> multiple times to select more than one. Note also that <code>--target</code> is not allowed to select targets that aren't specified by the config your Cargo.toml. This ensures that global installers are consistently aware of all the platform-specific artifacts they can fetch. (&quot;host&quot; mode breaks this rule.) ((Also in theory <code>--installer</code> should work the same for selecting specific installers but it's not well tested because there isn't any reason to ever use that outside of <code>cargo dist init</code>.))</p>
<p>CI will spin up one &quot;local&quot; task for each of the major desktop platforms, grouping the targets that are easy to build on those platforms together. In the future we might want to spawn one task per target, or at least make that an option you can pick. That said, some Artifacts like macOS universal binaries may find it useful to have multiple targets built on the same machine!</p>
<h2 id="host-artifacts-mode"><a class="header" href="#host-artifacts-mode">Host Artifacts Mode</a></h2>
<p>Host mode is the default &quot;do something useful on my machine&quot; mode. It's intended for testing and demoing cargo-dist on your project, and is never used in CI due to its intentionally fuzzy semantics.</p>
<p>It's currently roughly equivalent to <code>--artifacts=all --target=HOST_TARGET</code>, but HOST_TARGET is allowed to fall outside the set of targets defined in your Cargo.toml, because it's not terribly useful to tell someone trying out cargo-dist on ARM64 Linux that their platform isn't defined in the config.</p>
<p>In principle when we have better support for cross-compilation we might also try to build &quot;nice&quot; crosses like &quot;intel apple =&gt; arm64 apple&quot;. Do not rely on the behaviour of this mode, always use one of the 3 other modes in your infra/scripts!</p>
<p>If you <em>do</em> pass <code>--target</code> in host mode then we won't do fuzzy target selection and will just build the targets you ask for like normal.</p>
<h1 id="putting-it-all-together"><a class="header" href="#putting-it-all-together">Putting It All Together</a></h1>
<p>Ok so here's what goes through cargo-dist's brains when you run it:</p>
<ol>
<li>Read in the workspace/config/cli-flags</li>
<li>Determine the Announcement Tag (select the Apps) (&quot;v1.0.0&quot;)</li>
<li>Determine what Targets we're building for</li>
<li>Call the specific Version of each App a &quot;Release&quot; (&quot;my-app-v1.0.0&quot;)</li>
<li>For each Release-Target pair, create a &quot;ReleaseVariant&quot; (&quot;my-app-v1.0.0-x86_64-apple-darwin&quot;)</li>
<li>Add archive Artifacts to each Release (broadcasted to each Variant, filtered by Artifact Mode)</li>
<li>Add all the enabled Installers to each Release (local ones broadcasted to each Variant, filtered by Artifact Mode)</li>
<li>Compute the Build Steps necessary to produce each Artifact (&quot;run cargo, copy this file, ...&quot;)</li>
<li>Generate top-level Announcement info like the body for a Github Release</li>
<li>run the Build Steps (ignored by <code>manifest</code>/<code>plan</code>)</li>
<li>print a manifest of the computed Announcement/Releases/Artifacts</li>
</ol>
<p>CI will parse the resulting (<code>--output-format=json</code>) manifest of each <code>build</code> invocation to know what artifacts were produced and need to be uploaded to the Github Release.</p>
<p>CI will just invoke cargo-dist in the following sequence:</p>
<ol>
<li>create-release: <code>cargo dist manifest --artifacts=all --output-format=json --no-local-paths</code></li>
<li>upload-artifacts (local): <code>cargo dist build --artifacts=local --target=... --output-format=json</code></li>
<li>upload-artifacts (global): <code>cargo dist build --artifacts=global --output-format=json</code></li>
<li>publish-release: none, just marks the Github Release as a non-draft</li>
</ol>
<p>(All the upload-artifacts tasks are in parallel, and there are multiple &quot;local&quot; tasks to cover the target platforms.)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="artifact-url"><a class="header" href="#artifact-url">Artifact URL</a></h1>
<p><a href="reference/../installers/index.html">Fetching installers</a> need to know where to download the <a href="reference/../artifacts/archives.html">actual binaries</a> from, so cargo-dist needs to be aware of a base Artifact URL that it can derive download URLs from when it builds those kinds of installers.</p>
<h2 id="github"><a class="header" href="#github">GitHub</a></h2>
<p>Currently this functionality is restricted to <a href="reference/../ci/github.html">the &quot;github&quot; ci backend</a>, which uploads your artifacts to a GitHub Release. Because cargo-dist is fully in control of the uploading of your artifacts, it can automatically compute the Artifact URL for you, as:</p>
<pre><code class="language-text">{repo_url}/releases/download/{tag}
</code></pre>
<p>Where <code>repo_url</code> is the value of <code>repository</code> set in your Cargo.toml, and <code>tag</code> is the git tag of the release. For safety reasons, cargo-dist will refuse to define repo_url (and therefore the Artifact URL) unless all packages in your workspace that define <code>repository</code> agree on the value and have the format of <code>https://github.com/{owner}/{project}</code> (although we'll do some cleanups like trailing slashes or <code>.git</code>).</p>
<p>For example, if we want the linux build of axolotlsay 0.1.0, we have:</p>
<pre><code>* Cargo.toml &quot;repository&quot;: `https://github.com/axodotdev/axolotlsay/`
* git tag: `v0.1.0`
* artifact url: `https://github.com/axodotdev/axolotlsay/releases/download/v0.1.0/`
* download: `https://github.com/axodotdev/axolotlsay/releases/download/v0.1.0/axolotlsay-x86_64-unknown-linux-gnu.tar.gz`
</code></pre>
<h2 id="other"><a class="header" href="#other">Other</a></h2>
<p>Future releases <a href="https://github.com/axodotdev/cargo-dist/issues/236">will expose a more general mechanism for specifying artifact download URLs</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="config"><a class="header" href="#config">Config</a></h1>
<ul>
<li><a href="reference/config.html#relevant-cargotoml-fields">Relevant Cargo.toml Fields</a>
<ul>
<li><a href="reference/config.html#license-file">license-file</a></li>
<li><a href="reference/config.html#name">name</a></li>
<li><a href="reference/config.html#publish">publish</a></li>
<li><a href="reference/config.html#readme">readme</a></li>
<li><a href="reference/config.html#repository">repository</a></li>
<li><a href="reference/config.html#version">version</a></li>
</ul>
</li>
<li><a href="reference/config.html#workspacemetadatadist">workspace.metadata.dist</a>
<ul>
<li><a href="reference/config.html#allow-dirty">allow-dirty</a></li>
<li><a href="reference/config.html#all-features">all-features</a></li>
<li><a href="reference/config.html#auto-includes">auto-includes</a></li>
<li><a href="reference/config.html#build-global-artifacts-jobs">build-global-artifacts-jobs</a></li>
<li><a href="reference/config.html#build-local-artifacts-jobs">build-local-artifacts-jobs</a></li>
<li><a href="reference/config.html#cargo-dist-version">cargo-dist-version</a></li>
<li><a href="reference/config.html#checksum">checksum</a></li>
<li><a href="reference/config.html#ci">ci</a></li>
<li><a href="reference/config.html#create-release">create-release</a></li>
<li><a href="reference/config.html#default-features">default-features</a></li>
<li><a href="reference/config.html#dependencies">dependencies</a></li>
<li><a href="reference/config.html#dist">dist</a></li>
<li><a href="reference/config.html#extra-artifacts">extra-artifacts</a></li>
<li><a href="reference/config.html#fail-fast">fail-fast</a></li>
<li><a href="reference/config.html#features">features</a></li>
<li><a href="reference/config.html#host-jobs">host-jobs</a></li>
<li><a href="reference/config.html#hosting">hosting</a></li>
<li><a href="reference/config.html#include">include</a></li>
<li><a href="reference/config.html#installers">installers</a></li>
<li><a href="reference/config.html#install-path">install-path</a></li>
<li><a href="reference/config.html#merge-tasks">merge-tasks</a></li>
<li><a href="reference/config.html#msvc-crt-static">msvc-crt-static</a></li>
<li><a href="reference/config.html#npm-scope">npm-scope</a></li>
<li><a href="reference/config.html#plan-jobs">plan-jobs</a></li>
<li><a href="reference/config.html#post-announce-jobs">post-announce-jobs</a></li>
<li><a href="reference/config.html#precise-builds">precise-builds</a>
<ul>
<li><a href="reference/config.html#inferring-precise-builds">inferring precise-builds</a></li>
</ul>
</li>
<li><a href="reference/config.html#pr-run-mode">pr-run-mode</a></li>
<li><a href="reference/config.html#publish-jobs">publish-jobs</a></li>
<li><a href="reference/config.html#publish-prereleases">publish-prereleases</a></li>
<li><a href="reference/config.html#rust-toolchain-version">rust-toolchain-version</a></li>
<li><a href="reference/config.html#tap">tap</a></li>
<li><a href="reference/config.html#targets">targets</a></li>
<li><a href="reference/config.html#unix-archive">unix-archive</a></li>
<li><a href="reference/config.html#windows-archive">windows-archive</a></li>
</ul>
</li>
<li><a href="reference/config.html#subsetting-ci-flags">Subsetting CI Flags</a></li>
</ul>
<p>cargo-dist accepts configuration from the following sources, in order of increasing preference (that is, CLI flags generally replace things specified in your Cargo.toml):</p>
<ul>
<li>Relevant <a href="https://doc.rust-lang.org/cargo/reference/manifest.html">Cargo.toml fields</a> like &quot;repository&quot; and &quot;readme&quot;</li>
<li><code>[workspace.metadata.dist]</code></li>
<li><code>[package.metadata.dist]</code></li>
<li>CLI flags</li>
</ul>
<p>As discussed in <a href="reference/../reference/concepts.html">concepts</a>, all of your config should be persistently stored in the first 3 locations so that every run of cargo-dist agrees on what &quot;build everything&quot; should look like. CLI flags should primarily be used to select <em>subsets</em> of that &quot;everything&quot; for an individual run of cargo-dist to care about.</p>
<h2 id="relevant-cargotoml-fields"><a class="header" href="#relevant-cargotoml-fields">Relevant Cargo.toml Fields</a></h2>
<p>The <a href="https://doc.rust-lang.org/cargo/reference/manifest.html">builtin Cargo.toml fields</a> define a lot of things that cargo-dist cares about. Here's the ones that matter:</p>
<h3 id="license-file"><a class="header" href="#license-file">license-file</a></h3>
<p>cargo-dist defaults to trying to include certain &quot;important&quot; static files in your archives. A LICENSE is one of them.</p>
<p>If you specify a path to a license file, cargo-dist will use that for all packages it affects. Otherwise, cargo-dist will search for LICENSE* or UNLICENSE* files in the package's root directory and the workspace's root directory (preferring the package). If multiple are defined in the same directory, we will grab them all (this is necessary for the extremely common dual MIT/Apache license, which often results in two LICENSE-* files).</p>
<p>Note that the Cargo license-file flag only accepts one path, so it can't handle the dual-license-file case. This cargo feature largely exists as an escape hatch for weird licenses which can't be described by the SPDX format of the &quot;license&quot; field.</p>
<h3 id="name"><a class="header" href="#name">name</a></h3>
<p>The name of your package will become the name cargo-dist uses to refer to your package. There is currently no notion of a &quot;prettier display name&quot; (if you have a use for that, let us know!).</p>
<h3 id="publish"><a class="header" href="#publish">publish</a></h3>
<p>If you set <code>publish = false</code> in your Cargo.toml we will treat this as a hint that cargo-dist should ignore all the affected packages completely. You can override this with dist's own <code>dist = true</code> config.</p>
<h3 id="readme"><a class="header" href="#readme">readme</a></h3>
<p>cargo-dist defaults to trying to include certain &quot;important&quot; static files in your archives. A README is one of them.</p>
<p>If you specify a path to a README file, cargo-dist will use that for all the packages it affects. If you don't, then cargo-dist will search for a README* file in the package's root directory and the workspace's root directory (preferring the package).</p>
<h3 id="repository"><a class="header" href="#repository">repository</a></h3>
<p>cargo-dist has an internal notion of an &quot;artifact download URL&quot; that is required for things like <a href="reference/../installers/index.html">installers</a> that detect the current platform and fetch binaries. If your CI backend is &quot;github&quot; then we will base the &quot;<a href="reference/../reference/artifact-url.html">artifact download URL</a>&quot; on the &quot;repository&quot; key. To be safe, we will only do this if your workspace agrees on this value. It's fine if only some packages bother setting &quot;repository&quot;, as long as the ones that do use the exact same string. If they don't we will fail to compute an &quot;artifact download URL&quot;, emit a warning, and ignore your request for installers that require it. (This might want to be a hard error in the future.)</p>
<h3 id="version"><a class="header" href="#version">version</a></h3>
<p>The version of your package is used pervasively, and cargo-dist will generally error out if you ask it to build &quot;my-app-1.0.0&quot; when the actual &quot;my-app&quot; package is set to version &quot;1.1.0&quot;.</p>
<h2 id="workspacemetadatadist"><a class="header" href="#workspacemetadatadist">workspace.metadata.dist</a></h2>
<p>Cargo allows other tools to include their own project-wide settings in <a href="https://doc.rust-lang.org/cargo/reference/workspaces.html#the-metadata-table">metadata tables</a>. The one cargo-dist uses is <code>[workspace.metadata.dist]</code>, which must appear in your root Cargo.toml (whether or not it's <a href="https://doc.rust-lang.org/cargo/reference/workspaces.html">virtual</a>). You can override them on a per-package basis with <code>[package.metadata.dist]</code>, which accepts all the same fields (except for those which must be specified once globally, see the docs for each individual option).</p>
<h3 id="allow-dirty"><a class="header" href="#allow-dirty">allow-dirty</a></h3>
<blockquote>
<p>since 0.3.0</p>
</blockquote>
<p>Example: <code>allow-dirty = [&quot;ci&quot;, &quot;msi&quot;]</code></p>
<p>This is a list of generate tasks for cargo-dist to ignore when checking if generated configuration is up to date. It's useful for users who customize their own configuration beyond cargo-dist's generated defaults and want to avoid cargo-dist overwriting it.</p>
<p>Possible values are:</p>
<ul>
<li>&quot;ci&quot;: don't check/regenerate ci scripts (release.yml)</li>
<li>&quot;msi&quot;: don't check/regenerate msi templates (main.wxs)</li>
</ul>
<h3 id="all-features"><a class="header" href="#all-features">all-features</a></h3>
<blockquote>
<p>since 0.2.0</p>
</blockquote>
<p>Example: <code>all-features = true</code></p>
<p>Specifies that all features for a package should be enabled when building it (when set to true this tells us to pass <code>--all-features</code> to Cargo).</p>
<p>Defaults false.</p>
<p>If you use this you <em>probably</em> want to set it on <code>[package.metadata.dist]</code> and
not <code>[workspace.metadata.dist]</code>. See <a href="reference/config.html#inferring-precise-builds">&quot;inferring precise-builds&quot;</a> for details.</p>
<h3 id="auto-includes"><a class="header" href="#auto-includes">auto-includes</a></h3>
<blockquote>
<p>since 0.0.3</p>
</blockquote>
<p>Example: <code>auto-includes = false</code></p>
<p>Allows you to specify whether cargo-dist should auto-include README, (UN)LICENSE, and CHANGELOG/RELEASES files in <a href="reference/../artifacts/archives.html">archives</a>. Defaults to true.</p>
<h3 id="build-global-artifacts-jobs"><a class="header" href="#build-global-artifacts-jobs">build-global-artifacts-jobs</a></h3>
<blockquote>
<p>since 0.7.0</p>
</blockquote>
<p>Example: <code>build-global-artifacts-jobs = [&quot;./my-job&quot;]</code></p>
<p>This setting determines which custom jobs to run during the &quot;build global artifacts&quot; phase, during which installers are built.</p>
<h3 id="build-local-artifacts-jobs"><a class="header" href="#build-local-artifacts-jobs">build-local-artifacts-jobs</a></h3>
<blockquote>
<p>since 0.7.0</p>
</blockquote>
<p>Example: <code>build-local-artifacts-jobs = [&quot;./my-job&quot;]</code></p>
<p>This setting determines which custom jobs to run during the &quot;build local artifacts&quot; phase, during which binaries are built.</p>
<h3 id="cargo-dist-version"><a class="header" href="#cargo-dist-version">cargo-dist-version</a></h3>
<blockquote>
<p>since 0.0.3</p>
</blockquote>
<p>Example: <code>cargo-dist-version = &quot;0.0.3&quot;</code></p>
<p><strong>This can only be set globally</strong></p>
<p>This is added automatically by <code>cargo dist init</code>, and is a recording of its own version for the sake of reproducibility and documentation. When you run <a href="reference/../reference/cli.html#cargo-dist-generate">generate</a> the resulting CI scripts will use that version of cargo-dist to build your applications.</p>
<p>The syntax must be a valid <a href="https://docs.rs/semver/latest/semver/struct.Version.html">Cargo-style SemVer Version</a> (not a VersionReq!).</p>
<p>If you delete the key, generate will just use the version of cargo-dist that's currently running.</p>
<h3 id="checksum"><a class="header" href="#checksum">checksum</a></h3>
<blockquote>
<p>since 0.1.0</p>
</blockquote>
<p>Example: <code>checksum = &quot;sha512&quot;</code></p>
<p>Specifies how to checksum <a href="reference/../artifacts/archives.html">archives</a>. Supported values:</p>
<ul>
<li>&quot;sha256&quot; (default) - generate a .sha256 file for each archive</li>
<li>&quot;sha512&quot; - generate a .sha512 file for each archive</li>
<li>&quot;false&quot; - do not generate any checksums</li>
</ul>
<p>The hashes should match the result that sha256sum and sha512sum generate, and the file should be readable by those sorts of commands.</p>
<p>Future work is planned to <a href="https://github.com/axodotdev/cargo-dist/issues/120">support more robust signed checksums</a>.</p>
<h3 id="ci-1"><a class="header" href="#ci-1">ci</a></h3>
<blockquote>
<p>since 0.0.3</p>
</blockquote>
<p>Example: <code>ci = [&quot;github&quot;]</code></p>
<p><strong>This can only be set globally</strong></p>
<p>This is a list of CI backends you want to support, allowing subsequent runs of <a href="reference/../reference/cli.html#cargo-dist-generate">generate</a> to know what CI scripts to generate. Its presence also enables certain CI-specific features. For instance if &quot;github&quot; is included we'll try to generate the body for a Github Release and tell <a href="reference/../installers/index.html">installers</a> to fetch binaries from a Github Release.  Once we introduce more CI backends we'll need to more completely rationalize what that means. In all likelihood each set of CI scripts will need to explicitly select just its own CI by passing <code>--ci=...</code> for every invocation.</p>
<p>&quot;github&quot; is currently the only supported CI backend.</p>
<p><code>cargo dist init</code> can set this if you pass <code>--ci=...</code></p>
<h3 id="create-release"><a class="header" href="#create-release">create-release</a></h3>
<blockquote>
<p>since 0.2.0</p>
</blockquote>
<p>Example: <code>create-release = false</code></p>
<p><strong>This can only be set globally</strong></p>
<p>Whether we should create the Github Release for you in your Release CI.</p>
<p>If true (default), cargo-dist will create a new Github Release and generate
a title/body for it based on your changelog.</p>
<p>If false, cargo-dist will assume a draft Github Release for the current git tag
already exists with the title/body you want, and just upload artifacts to it.
At the end of a successful publish it will undraft the Github Release.</p>
<h3 id="default-features"><a class="header" href="#default-features">default-features</a></h3>
<blockquote>
<p>since 0.2.0</p>
</blockquote>
<p>Example: <code>default-features = false</code></p>
<p>Specifies that default features for a package should be enabled when building it (when set to false, this tells us to pass <code>--no-default-features</code> to Cargo).</p>
<p>Defaults true.</p>
<p>If you use this you <em>probably</em> want to set it on <code>[package.metadata.dist]</code> and not <code>[workspace.metadata.dist]</code>. See <a href="reference/config.html#inferring-precise-builds">&quot;inferring precise-builds&quot;</a> for details.</p>
<h3 id="dependencies"><a class="header" href="#dependencies">dependencies</a></h3>
<blockquote>
<p>since 0.4.0</p>
</blockquote>
<p>Allows specifying dependencies to be installed from a system package manager before the build begins. This is useful if your tool needs certain build tools (say, cmake) or links against C libraries provided by the package manager. This is specified in a Cargo-like format which should be familiar. Dependencies can be specified in two forms:</p>
<ul>
<li>A simple form, in which only a version is specified. If any version will do, use <code>'*'</code>.</li>
<li>A complex form, in several extra options can be specified.</li>
</ul>
<p>Supported options are:</p>
<ul>
<li><code>version</code> - A specific version of the package to install. This must be specified in the format that the package manager itself uses. Not used on Homebrew, since Homebrew does not support any method to specify installing specific versions of software.</li>
<li><code>stage</code> - When exactly cargo-dist should make use of this package. Two values are supported: <code>build</code>, which specifies that the package should be installed before the build occurs; and <code>run</code>, which specifies that the package should be installed alongside your software at the time end users run it. The default is <code>build</code>. If <code>run</code> is specified for Homebrew dependencies, and you've enabled the Homebrew installer, the Homebrew installer will specify those packages as dependencies.</li>
<li><code>targets</code> - A set of one or more targets to install the package on, in Rust target-triple format. If not specified, the package is installed on all targets. This is meant as an override to allow a package to be conditionally installed on only certain platforms; for example, a platform may need a build dependency only on Apple Silicon macOS, or have different build dependencies between x86_64 and ARM Windows.</li>
</ul>
<p>Supported package managers:</p>
<ul>
<li>Apt (Linux)</li>
<li>Chocolatey (Windows)</li>
<li>Homebrew (macOS)</li>
</ul>
<p>Example:</p>
<pre><code class="language-toml">[workspace.metadata.dist.dependencies.homebrew]
cmake = '*'
libcue = { stage = [&quot;build&quot;, &quot;run&quot;] }

[workspace.metadata.dist.dependencies.apt]
cmake = '*'
libcue-dev = { version = &quot;2.2.1-2&quot; }

[workspace.metadata.dist.dependencies.chocolatey]
lftp = '*'
cmake = { version = '3.27.6', targets = [&quot;aarch64-pc-windows-msvc&quot;] }
</code></pre>
<h3 id="dist"><a class="header" href="#dist">dist</a></h3>
<blockquote>
<p>since 0.0.3</p>
</blockquote>
<p>Example: <code>dist = false</code></p>
<p>Specifies whether cargo-dist should ignore this package. It primarily exists as an alternative for <code>publish=false</code> or an override for <code>publish=false</code>.</p>
<h3 id="extra-artifacts"><a class="header" href="#extra-artifacts">extra-artifacts</a></h3>
<blockquote>
<p>since 0.6.0</p>
</blockquote>
<p>Example:</p>
<pre><code class="language-toml">[[workspace.metadata.dist.extra-artifacts]]
artifacts = [&quot;dist-manifest-schema.json&quot;]
build = [&quot;cargo&quot;, &quot;dist&quot;, &quot;manifest-schema&quot;, &quot;--output=dist-manifest-schema.json&quot;]
</code></pre>
<p>Allows building extra artifacts to upload to your releases. Users can download these directly alongside artifacts like release tarballs or installers. To enable this feature, create an <code>extra-artifacts</code> array on your workspace or package configuration. This takes two keys:</p>
<ul>
<li><code>build</code>: A command or script to run to produce these artifacts. This is an array of one or more strings; the first string is the command cargo-dist will run, and any subsequent strings are arguments to pass to that command.</li>
<li><code>artifacts</code>: An array of artifacts that cargo-dist expects to exist after the <code>build</code> command is run. Every artifact in this list will be uploaded individually to your release.</li>
</ul>
<p>cargo-dist uses this feature to distribute its <code>dist-manifest-schema.json</code>.</p>
<h3 id="fail-fast"><a class="header" href="#fail-fast">fail-fast</a></h3>
<blockquote>
<p>since 0.1.0</p>
</blockquote>
<p>Example: <code>fail-fast = true</code></p>
<p><strong>This can only be set globally</strong></p>
<p>Whether failing tasks should make us give up on all other tasks. (defaults to false)</p>
<p>When building a release you might discover that an obscure platform's build is broken. When this happens you have two options: give up on the release entirely (<code>fail-fast = true</code>), or keep trying to build all the other platforms anyway (<code>fail-fast = false</code>).</p>
<p>cargo-dist was designed around the &quot;keep trying&quot; approach, as we create a draft Release
and upload results to it over time, undrafting the release only if all tasks succeeded.
The idea is that even if a platform fails to build, you can decide that's acceptable
and manually undraft the release with some missing platforms.</p>
<p>(Note that the dist-manifest.json is produced before anything else, and so it will assume
that all tasks succeeded when listing out supported platforms/artifacts. This may make
you sad if you do this kind of undrafting and also trust the dist-manifest to be correct.)</p>
<p>Prior to 0.1.0 we didn't set the correct flags in our CI scripts to do this, but now we do.
This flag was introduced to allow you to restore the old behaviour if you prefer.</p>
<h3 id="features"><a class="header" href="#features">features</a></h3>
<blockquote>
<p>since 0.2.0</p>
</blockquote>
<p>Example: <code>features = [&quot;serde-support&quot;, &quot;fancy-output&quot;]</code></p>
<p>Specifies feature-flags that should be passed to a package when building it. This lets you enable features that should be on &quot;in production&quot; but for whatever reason shouldn't be on by default.</p>
<p>For instance for packages that are a library and a CLI binary, some developers prefer to make the library the default and the CLI opt-in. In such a case you would want to add <code>features = [&quot;cli&quot;]</code> to your <code>[package.metadata.dist]</code>.</p>
<p>If you use this you <em>probably</em> want to set it on <code>[package.metadata.dist]</code> and
not <code>[workspace.metadata.dist]</code>. See <a href="reference/config.html#inferring-precise-builds">&quot;inferring precise-builds&quot;</a> for details.</p>
<h3 id="host-jobs"><a class="header" href="#host-jobs">host-jobs</a></h3>
<blockquote>
<p>since 0.7.0</p>
</blockquote>
<p>Example: <code>host-jobs = [&quot;./my-job&quot;]</code></p>
<p>This setting determines which custom jobs to run during the &quot;host&quot; phase, during which cargo-dist decides whether to proceed with publishing the release.</p>
<h3 id="hosting"><a class="header" href="#hosting">hosting</a></h3>
<blockquote>
<p>since 0.5.0</p>
</blockquote>
<p>Example: <code>hosting = [&quot;axodotdev&quot;, &quot;github&quot;]</code></p>
<p>Possible values:</p>
<ul>
<li><code>axodotdev</code>: Use Axo Releases (currently in closed beta)</li>
<li><code>github</code>: Use Github Releases (default if ci = &quot;github&quot;)</li>
</ul>
<p>Specifies what hosting provider to use when hosting/announcing new releases.</p>
<p>By default we will automatically use the native hosting of your CI provider, so when running on Github CI, we'll default to using Github Releases for hosting/announcing.</p>
<p>If Axo Releases and Github Releases are both enabled, we will host/announce on both platforms, but the Github Release's contents will regard the Axo Release as the canonical source for the files. Specifically if you have a shell installer, the Github Release will contain a shell installer that fetches from Axo Releases and it will tell you to <code>curl | sh</code> with a URL to Axo Releases.</p>
<p>(Ideally files uploaded to both hosts should be bitwise identical, which means we have to &quot;pick&quot;
a host to win for fetching installers, and if you're using Axo Releases at all you <em>probably</em> want that one to win.)</p>
<h3 id="include"><a class="header" href="#include">include</a></h3>
<blockquote>
<p>since 0.0.3</p>
</blockquote>
<p>Example: <code>include = [&quot;my-cool-file.txt&quot;, &quot;../other-cool-file.txt&quot;, &quot;./some/dir/&quot;]</code></p>
<p>This is a list of additional <em>files</em> or <em>directories</em> to copy into the root of all <a href="reference/../artifacts/archives.html">archives</a> that this setting affects. The paths are relative to the directory of the Cargo.toml that you placed this setting in. Globs are not supported.</p>
<h3 id="installers-1"><a class="header" href="#installers-1">installers</a></h3>
<blockquote>
<p>since 0.0.3</p>
</blockquote>
<p>Example: <code>installers = [&quot;shell&quot;, &quot;powershell&quot;]</code></p>
<p>This is a list of installers you want to be made for your application(s). In principle this can be overridden on a per-package basis but that is not well tested. See <a href="reference/../installers/index.html">the full docs on installers for the full list of values</a>.</p>
<p>See &quot;repository&quot; for some discussion on the &quot;Artifact Download URL&quot;.</p>
<h3 id="install-path"><a class="header" href="#install-path">install-path</a></h3>
<blockquote>
<p>since 0.1.0</p>
</blockquote>
<p>Example: <code>install-path = &quot;~/.my-app/&quot;</code></p>
<p>The strategy that script installers (<a href="reference/../installers/shell.html">shell</a>, <a href="reference/../installers/powershell.html">powershell</a>) should use for selecting a path to install things at, with 3 possible syntaxes:</p>
<ul>
<li>
<p><code>CARGO_HOME</code>: (default) installs as if <code>cargo install</code> did it (tries <code>$CARGO_HOME/bin/</code>, but if <code>$CARGO_HOME</code> isn't set uses <code>$HOME/.cargo/bin/</code>). Note that we do not (yet) properly update some of the extra metadata files Cargo maintains, so Cargo may be confused if you ask it to manage the binary.</p>
</li>
<li>
<p><code>~/some/subdir/</code>: installs to the given subdir of the user's <code>$HOME</code></p>
</li>
<li>
<p><code>$SOME_VAR/some/subdir</code>: installs to the given subdir of the dir defined by <code>$SOME_VAR</code></p>
</li>
</ul>
<blockquote>
<p>NOTE: <code>$HOME/some/subdir</code> is technically valid syntax but it won't behave the way you want on Windows, because <code>$HOME</code> isn't a proper environment variable. Let us handle those details for you and just use <code>~/subdir/</code>.</p>
</blockquote>
<p>All of these error out if none of the required env-vars are set to a non-empty value.</p>
<p>We do not currently sanitize/escape the path components (it's not really a security concern when the user is about to download+run an opaque binary anyway). In the future validation/escaping of this input will become more strict. We do appear to correctly handle spaces in paths on both windows and unix (i.e. <code>~/My cargo-dist Documents/bin/</code> works), but we won't be surprised if things misbehave on Interesting Inputs.</p>
<p>Future Improvements:</p>
<ul>
<li>In the future <a href="https://github.com/axodotdev/cargo-dist/issues/286">we may expand this setting to allow you to pass an array of options that are tried in sequence until one succeeds</a>.</li>
<li>In the future <a href="https://github.com/axodotdev/cargo-dist/issues/287">we may support XDG dirs</a></li>
<li>In the future <a href="https://github.com/axodotdev/cargo-dist/issues/288">we may support %windows dirs%</a></li>
</ul>
<p>(Please file an issue if you have other requirements!)</p>
<h3 id="merge-tasks"><a class="header" href="#merge-tasks">merge-tasks</a></h3>
<blockquote>
<p>since 0.1.0</p>
</blockquote>
<p>Example: <code>merge-tasks = true</code></p>
<p><strong>This can only be set globally</strong></p>
<p>Whether we should try to merge otherwise-parallelizable tasks onto the same machine, sacrificing latency and fault-isolation for more the sake of minor effeciency gains.</p>
<p>For example, if you build for x64 macos and arm64 macos, by default we will generate ci which builds those independently on separate logical machines. With this enabled we will build both of those platforms together on the same machine, making it take twice as long as any other build and making it impossible for only one of them to succeed.</p>
<p>The default is <code>false</code>. Before 0.1.0 it was always <code>true</code> and couldn't be changed, making releases annoyingly slow (and technically less fault-isolated). This config was added to allow you to restore the old behaviour, if you really want.</p>
<h3 id="msvc-crt-static"><a class="header" href="#msvc-crt-static">msvc-crt-static</a></h3>
<blockquote>
<p>since 0.4.0</p>
</blockquote>
<p>Example: <code>msvc-crt-static = false</code></p>
<p>Specifies how The C Runtime (CRT) should be linked when building for Windows. Rust defaults to this being <code>= false</code> (dynamically link the CRT), but cargo-dist actually defaults to making this <code>= true</code> (statically link the CRT). <a href="https://github.com/rust-lang/rfcs/blob/master/text/1721-crt-static.md#future-work">The Rust default is mostly a historical accident, and it's widely regarded to be an error that should one day be changed</a>. Specifically it's a mistake for the typical Rust application which statically links everything else, because Windows doesn't actually guarantee that the desired things are installed on all machines by default, and statically linking the CRT is a supported solution to this issue.</p>
<p>However when you <em>do</em> want a Rust application that dynamically links more things, it then becomes correct to dynamically link the CRT so that your app and the DLLs it uses can agree on things like malloc. However Rust's default is still insufficient for reliably shipping such a binary, because you really should also bundle a &quot;Visual C(++) Redistributable&quot; with your app that installs your required version of the CRT. The only case where it's <em>probably</em> fine to not do this is when shipping tools for programmers who probably already have all of that stuff installed (i.e. anyone who installs the Rust toolchain will have that stuff installed).</p>
<p>This config exists as a blunt way to return to the default Rust behaviour of dynamically linking the CRT if you really want it, but more work is needed to handle Redistributables for that usecase.</p>
<p><a href="https://github.com/axodotdev/cargo-dist/issues/496">See this issue for details and discussion</a>.</p>
<h3 id="npm-scope"><a class="header" href="#npm-scope">npm-scope</a></h3>
<blockquote>
<p>since 0.0.6</p>
</blockquote>
<p>Example: <code>npm-scope = &quot;@axodotdev&quot;</code></p>
<p>Specifies that <a href="reference/../installers/npm.html">npm installers</a> should be published under the given <a href="https://docs.npmjs.com/cli/v9/using-npm/scope">scope</a>. The leading <code>@</code> is mandatory. If you newly enable the npm installer in <code>cargo dist init</code>'s interactive UI, then it will give you an opportunity to add the scope.</p>
<p>If no scope is specified the package will be global.</p>
<h3 id="plan-jobs"><a class="header" href="#plan-jobs">plan-jobs</a></h3>
<blockquote>
<p>since 0.7.0</p>
</blockquote>
<p>Example: <code>plan-jobs = [&quot;./my-job&quot;]</code></p>
<p>This setting determines which custom jobs to run during the &quot;plan&quot; phase, which happens at the very start of the build.</p>
<h3 id="post-announce-jobs"><a class="header" href="#post-announce-jobs">post-announce-jobs</a></h3>
<blockquote>
<p>since 0.7.0</p>
</blockquote>
<p>Example: <code>post-announce-jobs = [&quot;./my-job&quot;]</code></p>
<p>This setting determines which custom jobs to run after the &quot;announce&quot; phase. &quot;Announce&quot; is the final phase during which cargo-dist schedules any jobs, so any custom jobs specified here are guaranteed to run after everything else.</p>
<h3 id="precise-builds"><a class="header" href="#precise-builds">precise-builds</a></h3>
<blockquote>
<p>since 0.1.0</p>
</blockquote>
<p>Example: <code>precise-builds = true</code></p>
<p><strong>This can only be set globally</strong></p>
<p>Build only the required packages, and individually.</p>
<p><a href="reference/config.html#inferring-precise-builds">See &quot;inferring precise-builds&quot; for the default behaviour.</a></p>
<p>By default when we need to build anything in your workspace, we try to build your entire workspace with <code>--workspace</code>. This setting tells cargo-dist to instead build each app individually.</p>
<p>On balance, the Rust experts we've consulted with find building with --workspace to be a safer/better default, as it provides some of the benefits of a more manual <a href="https://docs.rs/cargo-hakari/latest/cargo_hakari/about/index.html">workspace-hack</a>, without the user needing to be aware that this is a thing.</p>
<p>TL;DR: cargo prefers building one copy of each dependency in a build, so if two apps in your workspace depend on e.g. serde with different features, building with --workspace, will build serde once with the features unioned together. However if you build each package individually it will more precisely build two copies of serde with different feature sets.</p>
<p>The downside of using --workspace is that if your workspace has lots of example/test crates, or if you release only parts of your workspace at a time, we build a lot of gunk that's not needed, and potentially bloat up your app with unnecessary features.</p>
<p>If that downside is big enough for you, this setting is a good idea.</p>
<h4 id="inferring-precise-builds"><a class="header" href="#inferring-precise-builds">inferring precise-builds</a></h4>
<p>Although cargo-dist prefers <code>--workspace</code> builds (<a href="reference/config.html#precise-builds">precise-builds</a> = <code>false</code>) for the reasons stated above, it <em>will</em> attempt to check if that's possible, and use <code>--package</code> builds if necessary (<code>precise-builds = true</code>).</p>
<p>If you explicitly set <code>precise-builds = false</code> and we determine <code>--package</code> builds are required, cargo-dist will produce an error. <code>precise-builds = true</code> will never produce an error.</p>
<p>Precise-builds are considered required when you use any of <a href="reference/config.html#features">features</a>, <a href="reference/config.html#all-features">all-features</a>, or <a href="reference/config.html#default-features">default-features</a> <em>and</em> not all of the packages in your workspace have the same values set.</p>
<p>So for instance if you have several packages in your workspace and only one sets:</p>
<pre><code class="language-toml">[package.metadata.dist]
all-features = true
</code></pre>
<p>Then we will require precise-builds, and will pass <code>--all-features</code> to only the <code>cargo build</code> for that package. This setting, on the other hand:</p>
<pre><code class="language-toml">[workspace.metadata.dist]
all-features = true
</code></pre>
<p>Will just make us pass <code>--all-features</code> to <code>cargo build --workspace</code>.</p>
<h3 id="pr-run-mode"><a class="header" href="#pr-run-mode">pr-run-mode</a></h3>
<blockquote>
<p>since 0.3.0</p>
</blockquote>
<p>Example: <code>pr-run-mode = &quot;skip&quot;</code></p>
<p>This setting determines to what extent we run your Release CI on pull-requests:</p>
<ul>
<li>&quot;skip&quot;: don't check the release process in PRs</li>
<li>&quot;plan&quot;: run 'cargo dist plan' on PRs (recommended, also the default)</li>
<li>&quot;upload&quot;: build and upload an artifacts.zip to the PR (expensive)</li>
</ul>
<h3 id="publish-jobs"><a class="header" href="#publish-jobs">publish-jobs</a></h3>
<blockquote>
<p>since 0.2.0</p>
</blockquote>
<p>Example: <code>publish-jobs = [&quot;homebrew&quot;]</code></p>
<p>This setting determines which publish jobs to run. It includes one builtin job (<code>homebrew</code>) and, since 0.3.0, the ability to specify custom jobs.</p>
<h3 id="publish-prereleases"><a class="header" href="#publish-prereleases">publish-prereleases</a></h3>
<blockquote>
<p>since 0.2.0</p>
</blockquote>
<p>Example: <code>publish-prereleases = true</code></p>
<p>If you set <code>publish-prereleases = true</code>, cargo-dist will publish prerelease versions to package managers such as Homebrew. By default, cargo-dist will only publish stable versions.</p>
<h3 id="rust-toolchain-version"><a class="header" href="#rust-toolchain-version">rust-toolchain-version</a></h3>
<blockquote>
<p>since 0.0.3 (deprecated in 0.1.0)</p>
</blockquote>
<p>Example: <code>rust-toolchain-version = &quot;1.67.1&quot;</code></p>
<blockquote>
<p>Deprecation reason: <a href="https://rust-lang.github.io/rustup/overrides.html#the-toolchain-file">rust-toolchain.toml</a> is a more standard/universal mechanism for pinning toolchain versions for reproducibility. Teams without dedicated release engineers will likely benefit from unpinning their toolchain and letting the underlying CI vendor silently update them to &quot;some recent stable toolchain&quot;, as they will get updates/improvements and are unlikely to have regressions.</p>
</blockquote>
<p><strong>This can only be set globally</strong></p>
<p>This is added automatically by <code>cargo dist init</code>, recorded for the sake of reproducibility and documentation. It represents the &quot;ideal&quot; Rust toolchain to build your project with. This is in contrast to the builtin Cargo <a href="https://doc.rust-lang.org/cargo/reference/manifest.html#the-rust-version-field">rust-version</a> which is used to specify the <em>minimum</em> supported Rust version. When you run <a href="reference/../reference/cli.html#cargo-dist-generate">generate</a> the resulting CI scripts will install that version of the Rust toolchain with <a href="https://rust-lang.github.io/rustup/">rustup</a>. There's nothing special about the chosen value, it's just a hardcoded &quot;recent stable version&quot;.</p>
<p>The syntax must be a valid rustup toolchain like &quot;1.60.0&quot; or &quot;stable&quot; (should not specify the platform, we want to install this toolchain on all platforms).</p>
<p>If you delete the key, generate won't explicitly setup a toolchain, so whatever's on the machine will be used (with things like rust-toolchain.toml behaving as normal). Before being deprecated the default was to <code>rustup update stable</code>, but this is no longer the case.</p>
<h3 id="tap"><a class="header" href="#tap">tap</a></h3>
<blockquote>
<p>since 0.2.0</p>
</blockquote>
<p>Example: <code>tap = &quot;axodotdev/homebrew-formulae&quot;</code></p>
<p>This is the name of a GitHub repository which cargo-dist should publish the Homebrew installer to. It must already exist, and the token which creates releases must have write access.</p>
<p>See the <a href="reference/../installers/homebrew.html">installers documentation</a> for more information on Homebrew support.</p>
<h3 id="targets"><a class="header" href="#targets">targets</a></h3>
<blockquote>
<p>since 0.0.3</p>
</blockquote>
<p>Example: <code>targets = [&quot;x86_64-unknown-linux-gnu&quot;, &quot;x86_64-apple-darwin&quot;, &quot;x86_64-pc-windows-msvc&quot;]</code></p>
<p>This is a list of <a href="https://doc.rust-lang.org/nightly/rustc/platform-support.html">target platforms</a> you want your application(s) to be built for. In principle this can be overridden on a per-package basis but that is not well tested.</p>
<p>In v0.0.5 the only properly supported choices are:</p>
<ul>
<li>x64 macOS: &quot;x86_64-apple-darwin&quot;</li>
<li>x64 Windows: &quot;x86_64-pc-windows-msvc&quot;</li>
<li>x64 Linux: &quot;x86_64-unknown-linux-gnu&quot;</li>
<li>arm64 macOS (Apple silicon): &quot;aarch64-apple-darwin&quot; (support added in v0.0.4)</li>
</ul>
<p>Future versions should hopefully introduce proper support for important targets like &quot;musl linux&quot;.</p>
<p>By default all runs of <code>cargo-dist</code> will be trying to handle all platforms specified here at once. If you specify <code>--target=...</code> on the CLI this will focus the run to only those platforms. As discussed in <a href="reference/../reference/concepts.html">concepts</a>, this cannot be used to specify platforms that are not listed in <code>metadata.dist</code>, to ensure different runs agree on the maximum set of platforms.</p>
<h3 id="unix-archive"><a class="header" href="#unix-archive">unix-archive</a></h3>
<blockquote>
<p>since 0.0.5</p>
</blockquote>
<p>Example: <code>unix-archive = &quot;.tar.gz&quot;</code></p>
<p>Allows you to specify the file format to use for <a href="reference/../artifacts/archives.html">archives</a> that target not-windows. The default is
&quot;.tar.xz&quot;. See &quot;windows-archive&quot; below for a complete list of supported values.</p>
<h3 id="windows-archive"><a class="header" href="#windows-archive">windows-archive</a></h3>
<blockquote>
<p>since 0.0.5</p>
</blockquote>
<p>Example: <code>windows-archive = &quot;.tar.gz&quot;</code></p>
<p>Allows you to specify the file format to use for <a href="reference/../artifacts/archives.html">archives</a> that target windows. The default is
&quot;.zip&quot;. Supported values:</p>
<ul>
<li>&quot;.zip&quot;</li>
<li>&quot;.tar.gz&quot;</li>
<li>&quot;.tar.xz&quot;</li>
<li>&quot;.tar.zstd&quot;</li>
</ul>
<p>See also unix-archive below.</p>
<h2 id="subsetting-ci-flags"><a class="header" href="#subsetting-ci-flags">Subsetting CI Flags</a></h2>
<p>Several <code>metadata.dist</code> configs have globally available CLI equivalents. These can be used to select a subset of <code>metadata.dist</code> list for that run. If you don't pass any, it will be as-if you passed all the values in <code>metadata.dist</code>. You can pass these flags multiple times to provide a list. This includes:</p>
<ul>
<li><code>--target</code></li>
<li><code>--installer</code></li>
<li><code>--ci</code></li>
</ul>
<p>See <a href="reference/../reference/concepts.html#artifact-modes-selecting-artifacts">Artifact Modes</a> for how you might use this kind of subsetting.</p>
<p>Caveat: the default &quot;host&quot; Artifact Mode does something fuzzier with <code>--target</code> to allow you to build binaries that are usable on the current platform. Again see <a href="reference/../reference/concepts.html#artifact-modes-selecting-artifacts">Artifact Modes</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-dist-cli-manual"><a class="header" href="#cargo-dist-cli-manual">cargo-dist CLI Manual</a></h1>
<ul>
<li><a href="reference/cli.html#usage">Usage</a></li>
<li><a href="reference/cli.html#commands">Commands</a></li>
<li><a href="reference/cli.html#options">Options</a></li>
<li><a href="reference/cli.html#global-options">GLOBAL OPTIONS</a>
<ul>
<li><a href="reference/cli.html#-v---verbose-verbose"><code>-v, --verbose &lt;VERBOSE&gt;</code></a></li>
<li><a href="reference/cli.html#-o---output-format-output_format"><code>-o, --output-format &lt;OUTPUT_FORMAT&gt;</code></a></li>
<li><a href="reference/cli.html#--no-local-paths"><code>--no-local-paths</code></a></li>
<li><a href="reference/cli.html#-t---target-target"><code>-t, --target &lt;TARGET&gt;</code></a></li>
<li><a href="reference/cli.html#-i---installer-installer"><code>-i, --installer &lt;INSTALLER&gt;</code></a></li>
<li><a href="reference/cli.html#-c---ci-ci"><code>-c, --ci &lt;CI&gt;</code></a></li>
<li><a href="reference/cli.html#--tag-tag"><code>--tag &lt;TAG&gt;</code></a></li>
<li><a href="reference/cli.html#--allow-dirty"><code>--allow-dirty</code></a></li>
</ul>
</li>
<li><a href="reference/cli.html#cargo-dist-build">cargo dist build</a>
<ul>
<li><a href="reference/cli.html#usage-1">Usage</a></li>
<li><a href="reference/cli.html#options-1">Options</a>
<ul>
<li><a href="reference/cli.html#-a---artifacts-artifacts"><code>-a, --artifacts &lt;ARTIFACTS&gt;</code></a></li>
<li><a href="reference/cli.html#-p---print-print"><code>-p, --print &lt;PRINT&gt;</code></a></li>
<li><a href="reference/cli.html#-h---help"><code>-h, --help</code></a></li>
</ul>
</li>
<li><a href="reference/cli.html#global-options-1">GLOBAL OPTIONS</a></li>
</ul>
</li>
<li><a href="reference/cli.html#cargo-dist-init">cargo dist init</a>
<ul>
<li><a href="reference/cli.html#usage-2">Usage</a></li>
<li><a href="reference/cli.html#options-2">Options</a>
<ul>
<li><a href="reference/cli.html#-y---yes"><code>-y, --yes</code></a></li>
<li><a href="reference/cli.html#--no-generate"><code>--no-generate</code></a></li>
<li><a href="reference/cli.html#--with-json-config-with_json_config"><code>--with-json-config &lt;WITH_JSON_CONFIG&gt;</code></a></li>
<li><a href="reference/cli.html#--hosting-hosting"><code>--hosting &lt;HOSTING&gt;</code></a></li>
<li><a href="reference/cli.html#-h---help-1"><code>-h, --help</code></a></li>
</ul>
</li>
<li><a href="reference/cli.html#global-options-2">GLOBAL OPTIONS</a></li>
</ul>
</li>
<li><a href="reference/cli.html#cargo-dist-generate">cargo dist generate</a>
<ul>
<li><a href="reference/cli.html#usage-3">Usage</a></li>
<li><a href="reference/cli.html#arguments">Arguments</a></li>
<li><a href="reference/cli.html#options-3">Options</a>
<ul>
<li><a href="reference/cli.html#--check"><code>--check</code></a></li>
<li><a href="reference/cli.html#-h---help-2"><code>-h, --help</code></a></li>
</ul>
</li>
<li><a href="reference/cli.html#global-options-3">GLOBAL OPTIONS</a></li>
</ul>
</li>
<li><a href="reference/cli.html#cargo-dist-linkage">cargo dist linkage</a>
<ul>
<li><a href="reference/cli.html#usage-4">Usage</a></li>
<li><a href="reference/cli.html#options-4">Options</a>
<ul>
<li><a href="reference/cli.html#--print-output"><code>--print-output</code></a></li>
<li><a href="reference/cli.html#--print-json"><code>--print-json</code></a></li>
<li><a href="reference/cli.html#--from-json-from_json"><code>--from-json &lt;FROM_JSON&gt;</code></a></li>
<li><a href="reference/cli.html#-h---help-3"><code>-h, --help</code></a></li>
</ul>
</li>
<li><a href="reference/cli.html#global-options-4">GLOBAL OPTIONS</a></li>
</ul>
</li>
<li><a href="reference/cli.html#cargo-dist-manifest">cargo dist manifest</a>
<ul>
<li><a href="reference/cli.html#usage-5">Usage</a></li>
<li><a href="reference/cli.html#options-5">Options</a>
<ul>
<li><a href="reference/cli.html#-a---artifacts-artifacts-1"><code>-a, --artifacts &lt;ARTIFACTS&gt;</code></a></li>
<li><a href="reference/cli.html#-p---print-print-1"><code>-p, --print &lt;PRINT&gt;</code></a></li>
<li><a href="reference/cli.html#-h---help-4"><code>-h, --help</code></a></li>
</ul>
</li>
<li><a href="reference/cli.html#global-options-5">GLOBAL OPTIONS</a></li>
</ul>
</li>
<li><a href="reference/cli.html#cargo-dist-plan">cargo dist plan</a>
<ul>
<li><a href="reference/cli.html#usage-6">Usage</a></li>
<li><a href="reference/cli.html#options-6">Options</a>
<ul>
<li><a href="reference/cli.html#-h---help-5"><code>-h, --help</code></a></li>
</ul>
</li>
<li><a href="reference/cli.html#global-options-6">GLOBAL OPTIONS</a></li>
</ul>
</li>
<li><a href="reference/cli.html#cargo-dist-host">cargo dist host</a>
<ul>
<li><a href="reference/cli.html#usage-7">Usage</a></li>
<li><a href="reference/cli.html#options-7">Options</a>
<ul>
<li><a href="reference/cli.html#--steps-steps"><code>--steps &lt;STEPS&gt;</code></a></li>
<li><a href="reference/cli.html#-h---help-6"><code>-h, --help</code></a></li>
</ul>
</li>
<li><a href="reference/cli.html#global-options-7">GLOBAL OPTIONS</a></li>
</ul>
</li>
<li><a href="reference/cli.html#cargo-dist-help">cargo dist help</a>
<ul>
<li><a href="reference/cli.html#usage-8">Usage</a></li>
<li><a href="reference/cli.html#commands-1">Commands</a></li>
</ul>
</li>
</ul>
<blockquote>
<p>This manual can be regenerated with <code>cargo dist help-markdown</code></p>
</blockquote>
<p>Shippable packaging for Rust.</p>
<p>See 'init', 'build' and 'plan' for the 3 most important subcommands.</p>
<h3 id="usage"><a class="header" href="#usage">Usage</a></h3>
<pre><code class="language-text">cargo dist [OPTIONS]
</code></pre>
<p>cargo dist <COMMAND></p>
<h3 id="commands"><a class="header" href="#commands">Commands</a></h3>
<ul>
<li><a href="reference/cli.html#cargo-dist-build">build</a>: Build artifacts</li>
<li><a href="reference/cli.html#cargo-dist-init">init</a>: Setup or update cargo-dist</li>
<li><a href="reference/cli.html#cargo-dist-generate">generate</a>: Generate one or more pieces of configuration</li>
<li><a href="reference/cli.html#cargo-dist-linkage">linkage</a>: Report on the dynamic libraries used by the built artifacts</li>
<li><a href="reference/cli.html#cargo-dist-manifest">manifest</a>: Generate the final build manifest without running any builds</li>
<li><a href="reference/cli.html#cargo-dist-plan">plan</a>: Get a plan of what to build (and check project status)</li>
<li><a href="reference/cli.html#cargo-dist-host">host</a>: Host artifacts</li>
<li><a href="reference/cli.html#cargo-dist-help">help</a>: Print this message or the help of the given subcommand(s)</li>
</ul>
<h3 id="options"><a class="header" href="#options">Options</a></h3>
<h3 id="global-options"><a class="header" href="#global-options">GLOBAL OPTIONS</a></h3>
<h4 id="-v---verbose-verbose"><a class="header" href="#-v---verbose-verbose"><code>-v, --verbose &lt;VERBOSE&gt;</code></a></h4>
<p>How verbose logging should be (log level)</p>
<p>[default: warn]<br />
[possible values: off, error, warn, info, debug, trace]</p>
<h4 id="-o---output-format-output_format"><a class="header" href="#-o---output-format-output_format"><code>-o, --output-format &lt;OUTPUT_FORMAT&gt;</code></a></h4>
<p>The format of the output</p>
<p>[default: human]<br />
[possible values: human, json]</p>
<h4 id="--no-local-paths"><a class="header" href="#--no-local-paths"><code>--no-local-paths</code></a></h4>
<p>Strip local paths from output (e.g. in the dist manifest json)</p>
<p>This is useful for generating a clean &quot;full&quot; manifest as follows:</p>
<p><code>cargo dist manifest --artifacts=all --output-format=json --no-local-paths</code></p>
<h4 id="-t---target-target"><a class="header" href="#-t---target-target"><code>-t, --target &lt;TARGET&gt;</code></a></h4>
<p>Target triples we want to build</p>
<p>If left unspecified we will use the values in <a href="reference/./config.html#metadatadist">workspace.metadata.dist</a>, except for <code>cargo dist init</code> which will select some &quot;good defaults&quot; for you.</p>
<h4 id="-i---installer-installer"><a class="header" href="#-i---installer-installer"><code>-i, --installer &lt;INSTALLER&gt;</code></a></h4>
<p>Installers we want to build</p>
<p>If left unspecified we will use the values in <a href="reference/./config.html#metadatadist">workspace.metadata.dist</a>. <code>cargo dist init</code> will persist the values you pass to that location.</p>
<p>Possible values:</p>
<ul>
<li>shell:      Generates a shell script that fetches/installs the right build</li>
<li>powershell: Generates a powershell script that fetches/installs the right build</li>
<li>npm:        Generates an npm project that fetches the right build to your node_modules</li>
<li>homebrew:   Generates a Homebrew formula</li>
<li>msi:        Generates an msi for each windows platform</li>
</ul>
<h4 id="-c---ci-ci"><a class="header" href="#-c---ci-ci"><code>-c, --ci &lt;CI&gt;</code></a></h4>
<p>CI we want to support</p>
<p>If left unspecified we will use the value in <a href="reference/./config.html#metadatadist">workspace.metadata.dist</a>. <code>cargo dist init</code> will persist the values you pass to that location.</p>
<p>Possible values:</p>
<ul>
<li>github: Generate github CI that uploads to github releases</li>
</ul>
<h4 id="--tag-tag"><a class="header" href="#--tag-tag"><code>--tag &lt;TAG&gt;</code></a></h4>
<p>The (git) tag to use for the Announcement that each invocation of cargo-dist is performing.</p>
<p>This tag serves two purposes: defining which apps we are Announcing new Releases for (and therefore building binaries and installers for); and picking an id to use for certain URLs. For instance the git tag associated with a Github Release is part of the URL to fetch artifacts from that release, which needs to be known by some installers!</p>
<p>Unified Announcement: VERSION selects all packages with the given version (v1.0.0, 0.1.0-prerelease.1, releases/1.2.3, ...)</p>
<p>Singular Announcement: PACKAGE-VERSION or PACKAGE/VERSION selects only the given package (my-app-v1.0.0, my-app/1.0.0, release/my-app/v1.2.3-alpha, ...)</p>
<p>If you use the singular version then we will only Announce/Release that package's apps (and return an error if that is not in fact the package's current version). This is appropriate for workspaces that have more than one app.</p>
<p>If you use the unified version then we will assume you're Announcing/Releasing all packages in the workspace that have that version. This is appropriate for workspaces that only have one app, or for monorepos that version all their apps in lockstep.</p>
<p>If you do not specify this tag we will attempt to infer it by trying to Announce/Release every app in the workspace, succeeding only if they all have the same version. The tag selected will be &quot;v{VERSION}&quot;.</p>
<p>In the future we may try to make this look at the current git tags or something?</p>
<h4 id="--allow-dirty"><a class="header" href="#--allow-dirty"><code>--allow-dirty</code></a></h4>
<p>Allow generated files like CI scripts to be out of date</p>
<p><br><br><br></p>
<h2 id="cargo-dist-build"><a class="header" href="#cargo-dist-build">cargo dist build</a></h2>
<p>Build artifacts</p>
<h3 id="usage-1"><a class="header" href="#usage-1">Usage</a></h3>
<pre><code class="language-text">cargo dist build [OPTIONS]
</code></pre>
<h3 id="options-1"><a class="header" href="#options-1">Options</a></h3>
<h4 id="-a---artifacts-artifacts"><a class="header" href="#-a---artifacts-artifacts"><code>-a, --artifacts &lt;ARTIFACTS&gt;</code></a></h4>
<p>Which subset of the Artifacts to build</p>
<p>Artifacts can be broken up into two major classes: &quot;local&quot; ones, which are made for each target system (archives, symbols, msi installers...); and &quot;global&quot; ones, which are made once per app (curl-sh installers, npm package, metadata...).</p>
<p>Having this distinction lets us run cargo-dist independently on multiple machines without collisions between the outputs.</p>
<p>If let unspecified, we will pick a fuzzier &quot;host&quot; mode that builds &quot;as much as possible&quot; for the local system. This mode is appropriate for local testing/debugging/demoing. If no --target flags are passed on the CLI then &quot;host&quot; mode will try to intelligently guess which targets to build for, which may include building targets that aren't defined in your metadata.dist config (since that config may exclude the current machine!).</p>
<p>The specifics of &quot;host&quot; mode are intentionally unspecified to enable us to provider better out-of-the-box UX for local usage. In CI environments you should always specify &quot;global&quot; or &quot;local&quot; to get consistent behaviour!</p>
<p>[default: host]</p>
<p>Possible values:</p>
<ul>
<li>local:  Build target-specific artifacts like archives and msi installers</li>
<li>global: Build unique artifacts like curl-sh installers and npm packages</li>
<li>host:   Fuzzily build &quot;as much as possible&quot; for the host system</li>
<li>all:    Build all the artifacts; useful for <code>cargo dist manifest</code></li>
</ul>
<h4 id="-p---print-print"><a class="header" href="#-p---print-print"><code>-p, --print &lt;PRINT&gt;</code></a></h4>
<p>What extra information to print, if anything. Currently supported:</p>
<ul>
<li>linkage: prints information on dynamic libraries used by build artifacts</li>
</ul>
<h4 id="-h---help"><a class="header" href="#-h---help"><code>-h, --help</code></a></h4>
<p>Print help (see a summary with '-h')</p>
<h3 id="global-options-1"><a class="header" href="#global-options-1">GLOBAL OPTIONS</a></h3>
<p>This subcommand accepts all the <a href="reference/cli.html#global-options">global options</a></p>
<p><br><br><br></p>
<h2 id="cargo-dist-init"><a class="header" href="#cargo-dist-init">cargo dist init</a></h2>
<p>Setup or update cargo-dist</p>
<p>This will interactively guide you through the process of selecting configuration options and will also automatically run 'cargo dist generate' afterwards as necessary. It will also handle updating your project to a new version of cargo-dist if you're running one.</p>
<h3 id="usage-2"><a class="header" href="#usage-2">Usage</a></h3>
<pre><code class="language-text">cargo dist init [OPTIONS]
</code></pre>
<h3 id="options-2"><a class="header" href="#options-2">Options</a></h3>
<h4 id="-y---yes"><a class="header" href="#-y---yes"><code>-y, --yes</code></a></h4>
<p>Automatically accept all recommended/default values</p>
<p>This is equivalent to just mashing ENTER over and over during the interactive prompts.</p>
<h4 id="--no-generate"><a class="header" href="#--no-generate"><code>--no-generate</code></a></h4>
<p>Don't automatically invoke 'cargo dist generate' at the end</p>
<h4 id="--with-json-config-with_json_config"><a class="header" href="#--with-json-config-with_json_config"><code>--with-json-config &lt;WITH_JSON_CONFIG&gt;</code></a></h4>
<p>A path to a json file containing values to set in workspace.metadata.dist and package.metadata.dist, for building tools that edit these configs.</p>
<p>This is the same toml =&gt; json format that <code>cargo metadata</code> produces when reporting <code>workspace.metadata.dist</code>. There is some additional hierarchy for specifying which values go to which packages, but this is currently intentionally undocumented to give us some flexibility to change it.</p>
<h4 id="--hosting-hosting"><a class="header" href="#--hosting-hosting"><code>--hosting &lt;HOSTING&gt;</code></a></h4>
<p>releases hosting backends we want to support</p>
<p>If left unspecified we will use the value in <a href="reference/./config.html#metadatadist">workspace.metadata.dist</a>. (If no such value exists we will use the one &quot;native&quot; to your CI provider) <code>cargo dist init</code> will persist the values you pass to that location.</p>
<p>Possible values:</p>
<ul>
<li>github:    Host on Github Releases</li>
<li>axodotdev: Host on Axo Releases (&quot;Abyss&quot;)</li>
</ul>
<h4 id="-h---help-1"><a class="header" href="#-h---help-1"><code>-h, --help</code></a></h4>
<p>Print help (see a summary with '-h')</p>
<h3 id="global-options-2"><a class="header" href="#global-options-2">GLOBAL OPTIONS</a></h3>
<p>This subcommand accepts all the <a href="reference/cli.html#global-options">global options</a></p>
<p><br><br><br></p>
<h2 id="cargo-dist-generate"><a class="header" href="#cargo-dist-generate">cargo dist generate</a></h2>
<p>Generate one or more pieces of configuration</p>
<h3 id="usage-3"><a class="header" href="#usage-3">Usage</a></h3>
<pre><code class="language-text">cargo dist generate [OPTIONS] [MODE]...
</code></pre>
<h3 id="arguments"><a class="header" href="#arguments">Arguments</a></h3>
<p>[MODE]...<br />
Which type of configuration to generate</p>
<p>Possible values:</p>
<ul>
<li>ci:  Generate CI scripts for orchestrating cargo-dist</li>
<li>msi: Generate .wxs tempaltes for msi installers</li>
</ul>
<h3 id="options-3"><a class="header" href="#options-3">Options</a></h3>
<h4 id="--check"><a class="header" href="#--check"><code>--check</code></a></h4>
<p>Check if the generated output differs from on-disk config without writing it</p>
<h4 id="-h---help-2"><a class="header" href="#-h---help-2"><code>-h, --help</code></a></h4>
<p>Print help (see a summary with '-h')</p>
<h3 id="global-options-3"><a class="header" href="#global-options-3">GLOBAL OPTIONS</a></h3>
<p>This subcommand accepts all the <a href="reference/cli.html#global-options">global options</a></p>
<p><br><br><br></p>
<h2 id="cargo-dist-linkage"><a class="header" href="#cargo-dist-linkage">cargo dist linkage</a></h2>
<p>Report on the dynamic libraries used by the built artifacts</p>
<h3 id="usage-4"><a class="header" href="#usage-4">Usage</a></h3>
<pre><code class="language-text">cargo dist linkage [OPTIONS]
</code></pre>
<h3 id="options-4"><a class="header" href="#options-4">Options</a></h3>
<h4 id="--print-output"><a class="header" href="#--print-output"><code>--print-output</code></a></h4>
<p>Print human-readable output</p>
<h4 id="--print-json"><a class="header" href="#--print-json"><code>--print-json</code></a></h4>
<p>Print output as JSON</p>
<h4 id="--from-json-from_json"><a class="header" href="#--from-json-from_json"><code>--from-json &lt;FROM_JSON&gt;</code></a></h4>
<p>Read linkage data from JSON rather than parsing from binaries</p>
<h4 id="-h---help-3"><a class="header" href="#-h---help-3"><code>-h, --help</code></a></h4>
<p>Print help (see a summary with '-h')</p>
<h3 id="global-options-4"><a class="header" href="#global-options-4">GLOBAL OPTIONS</a></h3>
<p>This subcommand accepts all the <a href="reference/cli.html#global-options">global options</a></p>
<p><br><br><br></p>
<h2 id="cargo-dist-manifest"><a class="header" href="#cargo-dist-manifest">cargo dist manifest</a></h2>
<p>Generate the final build manifest without running any builds.</p>
<p>This command is designed to match the exact behaviour of 'cargo dist build' when passed the same flags, which is nice for consistency but annoying for anyone who doesn't understand cargo-dist's design really well.</p>
<p>Notably it will default to only talking about artifacts for the host system, and will produce paths to the build dir that may not exist (since the build wasn't run).</p>
<p>'cargo dist plan' is an alias for this command that picks nicer defaults by forcing a couple flags to have specific values. You probably want that.</p>
<h3 id="usage-5"><a class="header" href="#usage-5">Usage</a></h3>
<pre><code class="language-text">cargo dist manifest [OPTIONS]
</code></pre>
<h3 id="options-5"><a class="header" href="#options-5">Options</a></h3>
<h4 id="-a---artifacts-artifacts-1"><a class="header" href="#-a---artifacts-artifacts-1"><code>-a, --artifacts &lt;ARTIFACTS&gt;</code></a></h4>
<p>Which subset of the Artifacts to build</p>
<p>Artifacts can be broken up into two major classes: &quot;local&quot; ones, which are made for each target system (archives, symbols, msi installers...); and &quot;global&quot; ones, which are made once per app (curl-sh installers, npm package, metadata...).</p>
<p>Having this distinction lets us run cargo-dist independently on multiple machines without collisions between the outputs.</p>
<p>If let unspecified, we will pick a fuzzier &quot;host&quot; mode that builds &quot;as much as possible&quot; for the local system. This mode is appropriate for local testing/debugging/demoing. If no --target flags are passed on the CLI then &quot;host&quot; mode will try to intelligently guess which targets to build for, which may include building targets that aren't defined in your metadata.dist config (since that config may exclude the current machine!).</p>
<p>The specifics of &quot;host&quot; mode are intentionally unspecified to enable us to provider better out-of-the-box UX for local usage. In CI environments you should always specify &quot;global&quot; or &quot;local&quot; to get consistent behaviour!</p>
<p>[default: host]</p>
<p>Possible values:</p>
<ul>
<li>local:  Build target-specific artifacts like archives and msi installers</li>
<li>global: Build unique artifacts like curl-sh installers and npm packages</li>
<li>host:   Fuzzily build &quot;as much as possible&quot; for the host system</li>
<li>all:    Build all the artifacts; useful for <code>cargo dist manifest</code></li>
</ul>
<h4 id="-p---print-print-1"><a class="header" href="#-p---print-print-1"><code>-p, --print &lt;PRINT&gt;</code></a></h4>
<p>What extra information to print, if anything. Currently supported:</p>
<ul>
<li>linkage: prints information on dynamic libraries used by build artifacts</li>
</ul>
<h4 id="-h---help-4"><a class="header" href="#-h---help-4"><code>-h, --help</code></a></h4>
<p>Print help (see a summary with '-h')</p>
<h3 id="global-options-5"><a class="header" href="#global-options-5">GLOBAL OPTIONS</a></h3>
<p>This subcommand accepts all the <a href="reference/cli.html#global-options">global options</a></p>
<p><br><br><br></p>
<h2 id="cargo-dist-plan"><a class="header" href="#cargo-dist-plan">cargo dist plan</a></h2>
<p>Get a plan of what to build (and check project status)</p>
<p>If you want to know what running your cargo-dist CI will produce, this is the command for you! This is the exact command that CI will run to make its build plan and generate dist-manifest.json (although it adds --output-format=json so that it's machine-readable).</p>
<p>This is an alias for the lower-level 'manifest' command with the appropriate flags forced for asking for &quot;everything&quot;</p>
<p>cargo dist manifest --artifacts=all --no-local-paths</p>
<h3 id="usage-6"><a class="header" href="#usage-6">Usage</a></h3>
<pre><code class="language-text">cargo dist plan [OPTIONS]
</code></pre>
<h3 id="options-6"><a class="header" href="#options-6">Options</a></h3>
<h4 id="-h---help-5"><a class="header" href="#-h---help-5"><code>-h, --help</code></a></h4>
<p>Print help (see a summary with '-h')</p>
<h3 id="global-options-6"><a class="header" href="#global-options-6">GLOBAL OPTIONS</a></h3>
<p>This subcommand accepts all the <a href="reference/cli.html#global-options">global options</a></p>
<p><br><br><br></p>
<h2 id="cargo-dist-host"><a class="header" href="#cargo-dist-host">cargo dist host</a></h2>
<p>Host artifacts</p>
<h3 id="usage-7"><a class="header" href="#usage-7">Usage</a></h3>
<pre><code class="language-text">cargo dist host [OPTIONS]
</code></pre>
<h3 id="options-7"><a class="header" href="#options-7">Options</a></h3>
<h4 id="--steps-steps"><a class="header" href="#--steps-steps"><code>--steps &lt;STEPS&gt;</code></a></h4>
<p>The hosting steps to perform</p>
<p>Possible values:</p>
<ul>
<li>check:    Check that hosting is properly setup without doing other effects</li>
<li>create:   Create a location to host artifacts</li>
<li>upload:   Upload artifacts</li>
<li>release:  Release artifacts</li>
<li>announce: Announce artifacts</li>
</ul>
<h4 id="-h---help-6"><a class="header" href="#-h---help-6"><code>-h, --help</code></a></h4>
<p>Print help (see a summary with '-h')</p>
<h3 id="global-options-7"><a class="header" href="#global-options-7">GLOBAL OPTIONS</a></h3>
<p>This subcommand accepts all the <a href="reference/cli.html#global-options">global options</a></p>
<p><br><br><br></p>
<h2 id="cargo-dist-help"><a class="header" href="#cargo-dist-help">cargo dist help</a></h2>
<p>Print this message or the help of the given subcommand(s)</p>
<h3 id="usage-8"><a class="header" href="#usage-8">Usage</a></h3>
<pre><code class="language-text">cargo dist help [COMMAND]
</code></pre>
<h3 id="commands-1"><a class="header" href="#commands-1">Commands</a></h3>
<ul>
<li><a href="reference/cli.html#cargo-dist-build">build</a>: Build artifacts</li>
<li><a href="reference/cli.html#cargo-dist-init">init</a>: Setup or update cargo-dist</li>
<li><a href="reference/cli.html#cargo-dist-generate">generate</a>: Generate one or more pieces of configuration</li>
<li><a href="reference/cli.html#cargo-dist-linkage">linkage</a>: Report on the dynamic libraries used by the built artifacts</li>
<li><a href="reference/cli.html#cargo-dist-manifest">manifest</a>: Generate the final build manifest without running any builds</li>
<li><a href="reference/cli.html#cargo-dist-plan">plan</a>: Get a plan of what to build (and check project status)</li>
<li><a href="reference/cli.html#cargo-dist-host">host</a>: Host artifacts</li>
<li><a href="reference/cli.html#cargo-dist-help">help</a>: Print this message or the help of the given subcommand(s)</li>
</ul>
<p>stderr:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="json-schema"><a class="header" href="#json-schema">JSON Schema</a></h1>
<p>Many cargo-dist commands when run with <code>--output-format=json</code> will output to stdout a format we call &quot;dist-manifest.json&quot;. This contains:</p>
<ul>
<li>Top-level facts about the Announcement (tag, announcement title, etc)</li>
<li>Info about the Apps being Released as part of the Announcement (&quot;releases&quot;)</li>
<li>Info about the Artifacts included in the Announcement (&quot;announcements&quot;)</li>
</ul>
<p>As a matter of forward-compat and back-compat, basically every field in the format should be treated as optional (which the schema reflects).</p>
<p>The latest schema can be found at:</p>
<p>https://github.com/axodotdev/cargo-dist/releases/latest/download/dist-manifest-schema.json</p>
<p>An example dist-manifest can be found at:</p>
<p>https://github.com/axodotdev/axolotlsay/releases/latest/download/dist-manifest.json</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
